

                ;*****************************************************************************
                ;
                ;  Flop2PC - Transfer floppy image to PC over a serial port
                ;		(for JADE Double D controller)
                ;
                ;	This program transmits an image of a SSSD soft-sectored 8" floppy
                ;	to a PC. The image is transmitted through a 2SIO at I/O address
                ;	010h or 012h, or an SIO at address 0 using the XMODEM protocol.
                ;
                ;	The program talks directly to the JADE Double D  controller and
                ;	does not require CP/M or an OS to function.
                ;
                ;	This program works best if console port and the transfer port
                ;	are not the same device. Otherwise, most error messages won't
                ;	be seen as the file transfer dialog box prevents their display.
                ;
                ;	The program runs standalone at 0x100 or under CP/M. The program
                ;	is exited with a CTRL-C and either warm boots CP/M or just starts
                ;       over when running stand alone.
                ;
                ;	Written by Mike Douglas
                ;	Modified for JADE Double D by Patrick Linstruth
                ;
                ;	Rev	 Date	    Desc
                ;	1.0	05/24/20    Original
                ;
                ;*****************************************************************************
                
                ; Disk information equates
                
 004D =         NUMTRK	equ	77		;number of tracks
 001A =         NUMSEC	equ	26		;number of sectors per track
 0032 =         NUMSEC1	equ	50		;number of sectors per track
 0018 =         XTRASEC	equ	(NUMSEC1-NUMSEC);extra sectors to read on first pass
 0080 =         SECLEN	equ	128		;sector length (as transmitted)
 0000 =         MINDRV	equ	0		;first drive number
 0003 =         MAXDRV	equ	3		;max drive number 
                
 0D00 =         TRKLEN	equ	(NUMSEC*SECLEN)	;length of track in bytes
 1900 =         TRKLEN1	equ	(NUMSEC1*SECLEN);length of track in bytes
 0C00 =         XTRALEN	equ	(XTRASEC*SECLEN);extra length of track 1
 0003 =         RDTRIES	equ	3		;disk retries per retry step
                
                ; Specify head settle delay (in addition to the 10ms step delay provided
                ;    by the 1771), and the amount of time to delay between reversing
                ;    track steps (e.g., step in/out or step out/in sequence). 
                ;
                ; Set ONEMS to give a 1ms delay for a 19 cycle loop (8080) or a 18 cycle
                ;    loop (Z80)
                
 000A =         HDSETL	equ	10		;10ms additional head settle after step
 000A =         STPREV	equ	10		;10ms delay when reversing step direction
 0069 =         ONEMS	equ	105		;105*19 cycles = 1ms at 2Mhz (8080)
                ;ONEMS	equ	267		;222*18 cycles = 1ms at 4Mhz (Z80)
                
                ; Monitor, CP/M boot entry points
                
                MONITOR	set	init		;no monitor, just start over
                CPMBOOT	set	0		;CP/M warm boot jump vector
                
                ; XMODEM equates
                
 0080 =         PKTLEN	equ	128		;128 byte xmodem packet length
 0001 =         SOH	equ	001h
 0004 =         EOT	equ	004h
 0006 =         ACK	equ	006h
 0015 =         NAK	equ	015h
 001A =         EOF	equ	01ah		;ctrl-z character
 000A =         XMTRIES	equ	10		;number of xmodem retries
                
                ; CP/M Equates
                
 0000 =         WBOOT	equ	0		;warm boot jump vector
                
                ; Misc equates
                
 000D =         CR	equ	13		;ascii for carriage return
 000A =         LF	equ	10		;ascii for line feed
 007F =         DEL	equ	7fh		;ascii DEL
 0008 =         BS	equ	08h		;ascii backspace
 0003 =         CTRLC	equ	03		;ascii for control-c
 00C3 =         JMPINST	equ	0c3h		;jump instruction opcode
                
 0100           	org	0100h		;load address
                ;-----------------------------------------------------------------------------
                ;   Initialize for transfer
                ;-----------------------------------------------------------------------------
 0100 316509    init	lxi	sp,ourStk	;initialize stack pointer
 0103 CD2204    	call	chkCpm		;set flag for CP/M or not
 0106 CD6004    	call	sizeRam		;determine amount of RAM available
 0109 CD9B07    	call	s2Init		;initialize the 88-2SIO ports
 010C 3E00      	mvi	a,MINDRV	;a=default drive
 010E 329008    	sta	drvNum		;need for pgmExit
                
                ;  Display welcome message, then get the drive number and port number
                ;    to use for the transfer from the operator.
                
 0111 21B904    	lxi	h,mWelcom	;display welcome message
 0114 CD4D03    	call	dispMsg
                
                ; getDrv - get drive number or letter from the user.
                
                ; getDrv - get drive number or letter from the user.
                
 0117 217D05    getDrv	lxi	h,mDrive	;display drive number prompt
 011A CD4D03    	call	dispMsg
 011D CD5803    	call	rcvCon		;get byte from the console
 0120 F620      	ori	20h		;upper case letters to lower case
 0122 FE78      	cpi	'x'		;exit requested?
 0124 CAF003    	jz	pgmExit		;yes
                
 0127 212409    	lxi	h,baseDrv	;ascii 1st drive - baseDrv = 0
 012A 96        	sub	m
 012B FE04      	cpi	MAXDRV-MINDRV+1	;validate >=min drive and <= max drive
 012D D21701    	jnc	getDrv		;invalid, prompt again
                
 0130 C600      	adi	MINDRV		;restore offset of 1st drive (if any)
 0132 329008    	sta	drvNum		;save the drive number to use
                
                ; Check if DCM is running and drive status
                
 0135 CD1B0A    	call	INI$DD
 0138 CA4101    	jz	getPort		;DCM found and running
 013B CD1A0B    	call	DCM$ER		;display DCM error
 013E C31701    	jmp	getDrv
                
                ; getPort - get serial port number from the user.
                
 0141 21B505    getPort	lxi	h,mPort		;display transfer port prompt
 0144 CD4D03    	call	dispMsg
 0147 CD5803    	call	rcvCon		;get byte from the console
 014A F620      	ori	20h		;upper to lower case, nums not affected
 014C FE78      	cpi	'x'		;exit requested?
 014E CAF003    	jz	pgmExit		;yes
                
 0151 D631      	sui	'1'		;'1' - '3' to bianry 0-2
 0153 FE03      	cpi	3		;validate ascii 1-3
 0155 D24101    	jnc	getPort		;invalid, prompt again
                
 0158 321B09    	sta	xfrPort		;save the port to use
                
                ; Prompt the user to start the XMODEM receive operation on the PC. 
                ;    Wait for a clear receive line for a least one second, then start
                ;    looking for NAK or 'C' (crc protocol) from the PC
                
 015B 214F06    	lxi	h,mStart	;display start file transfer prompt
 015E CD4D03    	call	dispMsg
                
 0161 0601      clrRcv1	mvi	b,1		;1 second
 0163 CD8F03    	call	rcvByte		;loop until input clear for 1 second
 0166 C26101    	jnz	clrRcv1
                
 0169 AF        	xra	a		;set CRC flag to false (checksum mode)
 016A 321E09    	sta	crcFlag
                
 016D CDE103    waitNak	call	chkQuit		;give user chance to abort
 0170 0601      	mvi	b,1		;1 second timeout
 0172 CD8F03    	call	rcvByte		;wait for a character
 0175 FE15      	cpi	NAK
 0177 CA8201    	jz	haveNak		;have a NAK, use checksum protocol
                
 017A FE43      	cpi	'C'		;CRC protocol requested?
 017C C26D01    	jnz	waitNak		;no
                
 017F 321E09    	sta	crcFlag		;set crc flag non-zero = CRC mode
                
                ;  NAK or 'C' received meaning the XMODEM receive has started. Initialize
                ;     for the transfer.
                
 0182 AF        haveNak	xra	a		;init track we want to zero
 0183 329108    	sta	trkNum
                
 0186 3C        	inr	a		;init xmodem block number to one
 0187 321D09    	sta	blkNum
                
 018A 212B0B    	lxi	h,trkBuf	;trkBuf is initial starting point for
 018D 222109    	shld	sndPtr		;   XMODEM send
                
                ;-----------------------------------------------------------------------------
                ;  mainLp - Loop through all tracks on the disk buffering as many tracks
                ;    as will fit in RAM before sending via xmodem, then repeat.
                ;-----------------------------------------------------------------------------
 0190 212B0B    mainLp	lxi	h,trkBuf	;disk buffering always start at trkBuf
 0193 229408    	shld	trkPtr
                
                ; Read and buffer bufTrks tracks unless all tracks on drive reached first
                
 0196 CDD901    bufLoop	call	readTrk		;read into trkBuf
                
 0199 3A9108    	lda	trkNum		;increment track number (preserve HL)
 019C 3C        	inr	a
 019D 329108    	sta	trkNum	
 01A0 FE4D      	cpi	NUMTRK		;done all tracks on the disk?
 01A2 CAB601    	jz	sendBuf		;yes, go send the buffered tracks
                
 01A5 3A1A09    	lda	trkErr		;read failure on the track?
 01A8 B7        	ora	a		;if so, send buffered tracks now
 01A9 C2B601    	jnz	sendBuf		;so XMODEM won't time out
                
 01AC EB        	xchg			;de=current track pointer
 01AD 2A9608    	lhld	bufEnd		;hl=end of buffering space
 01B0 CDA104    	call	cmpDeHl		;compare current-end
 01B3 DA9601    	jc	bufLoop		;still room, keep going	
                
                ; Track buffer is full or all tracks have been read. Send the buffered
                ;    tracks via xmodem.
                
 01B6 CD4002    sendBuf	call	sndTrks		;send the buffered tracks via xmodem
 01B9 3A9108    	lda	trkNum
 01BC FE4D      	cpi	NUMTRK		;done all tracks?
 01BE C29001    	jnz	mainLp		;no, not done yet
                
                ; The entire disk has been read and (mostly) transmitted. See if there are
                ;    left over bytes to send. If so, send them.
                
 01C1 7D        	mov	a,l		;hl->next packet to send, a=lsb of ptr
 01C2 FE2B      	cpi	trkBuf AND 0ffh	;pointing to lsb of address of trkBuf?
 01C4 CACA01    	jz	noExtra		;same, no extra bytes to send
                
 01C7 CD7602    	call	sndPkt		;otherwise, send one last packet
                
                ; Send EOT and wait for response. Then display the success message and
                ;    start the program over.
                
 01CA CD2803    noExtra	call	sndEot		;send and get response for EOT
 01CD CD5408    	call	dRestor		;seek to track 0
 01D0 218206    	lxi	h,mDone		;print the all done message
 01D3 CD4D03    	call	dispMsg
 01D6 C31701    	jmp	getDrv		;start over asking for a drive
                	
                ;-----------------------------------------------------------------------------
                ; readTrk - read numSecs sectors from the current track into a trkBuf as
                ;   pointed to by trkPtr. After the track is read, trkPtr is updated
                ;   by the length of a track to point to the next track buffer. This
                ;   saved value is also returned in HL.
                ;-----------------------------------------------------------------------------
 01D9 219108    readTrk	lxi	h,trkNum	;get desired track from trkNum	
 01DC 6E        	mov	l,m		;and put into l
 01DD CD4D08    	call	dSeek		;seek to the track
                
 01E0 AF        	xra	a
 01E1 321A09    	sta	trkErr		;no error on this track yet
                
 01E4 3E02      	mvi	a,2		;init retry step
 01E6 321909    	sta	rtStep
                
 01E9 1E00      	mvi	e,0		;reset sector
                
                ; Read an entire track. Start after the sector in e. 
                
 01EB 3A9208    	lda	numSecs
 01EE 57        	mov	d,a		;d=sector counter
                
 01EF CD7808    secLoop	call	dNxtSec		;e=next sector, bc=offset within track
                
 01F2 2A9408    stpLoop	lhld	trkPtr		;hl->start of current track buffer
 01F5 09        	dad	b		;hl->sector buffer
                
 01F6 CDE103    	call	chkQuit		;check for ctrl-c from operator
                
 01F9 CD0C08    	call	dRead		;read the sector
 01FC C21902    	jnz	secRtry		;error, run retry logic	
                
                ; Decrement sector count. If full track is done, increment trkPtr
                ;   to point to the next track buffer in trkBuf and exit.
                
 01FF 15        nxtSec	dcr	d		;decrement sector count
 0200 C2EF01    	jnz	secLoop
                
 0203 2A9408    	lhld	trkPtr		;hl=current track pointer
 0206 110019    	lxi	d,TRKLEN1	;de=bytes in a track 1
 0209 3A9108    	lda	trkNum		;track 1?
 020C FE01      	cpi	1
 020E CA1402    	jz	trk1
                
 0211 11000D    	lxi	d,TRKLEN	;de=bytes in a track 0,2-76
 0214 19        trk1	dad	d		;hl=start of next track in trkBuf
 0215 229408    	shld	trkPtr
 0218 C9        	ret
                
                ;--------------------------------------------------------------------------
                ; secRtry - Read error retry logic.
                ;
                ;    Upon entry, if the error is "sector not found," then retries are
                ;    not performed since the controller has already tried to read the
                ;    address mark across three revolutions.
                ;--------------------------------------------------------------------------	
 0219 E610      secRtry	ani	ST$RNF		;sector not found error?
 021B C2FF01    	jnz	nxtSec		;yes, skip retries, go to next sector
                
 021E 3E03      	mvi	a,RDTRIES	;init retry counter
 0220 321809    	sta	rdRtry
                
 0223 CD8608    retryLp	call	dWtSec		;get bc=offset of sector e in track
 0226 2A9408    	lhld	trkPtr		;hl->start of current track buffer
 0229 09        	dad	b		;hl->sector buffer
                
 022A CDE103    	call	chkQuit		;check for ctrl-c
                	
 022D CD0C08    	call	dRead		;read the sector
 0230 CAFF01    	jz	nxtSec		;success, retry is done
                
 0233 211809    	lxi	h,rdRtry	;decrement retry counter
 0236 35        	dcr	m
 0237 C22302    	jnz	retryLp		;try again
                
                ; Retry failed. Display the error, then jump back into the main
                ;    read loop which will resume at the next sector.
                
 023A CDA403    	call	dspErr		;give up, display the error
 023D C3FF01    	jmp	nxtSec
                
                ;-----------------------------------------------------------------------------
                ; sndTrks - send the tracks buffered in trkBuf via xmodem. trkPtr points
                ;    to the end+1 of the data to send
                ;-----------------------------------------------------------------------------
 0240 2A9408    sndTrks	lhld	trkPtr		;hl=end of buffered data + 1
 0243 EB        	xchg			;de=end of buffered data + 1
 0244 2A2109    	lhld	sndPtr		;hl=start tranmission address
                
 0247 D5        sndLoop	push	d		;save end pointer
 0248 CD7602    	call	sndPkt		;send a packet
 024B D1        	pop	d		;de=end pointer
                
                ; At this point, hl->start of next packet and de->last byte read from disk+1.
                ;    If the next XMODEM packet will go past the end of the disk data,
                ;    we don't want to send it yet.
                
 024C 018000    	lxi	b,PKTLEN	;bc=length of XMODEM packet
 024F 09        	dad	b		;hl=address at end of NEXT packet + 1
 0250 CDA104    	call	cmpDeHl		;compare disk end - end of next packet
 0253 DA5D02    	jc	sndDone		;next packet will pass the end, stop
                
 0256 0180FF    	lxi	b,-PKTLEN	;restore hl
 0259 09        	dad	b
 025A C34702    	jmp	sndLoop
                
                ; sndDone - all the packets we can send have been sent. Move any bytes
                ;    left over to just before the start of trkBuf. The next group of
                ;    xmodem packets will be transmitted starting there.
                
 025D CDA604    sndDone	call	subDeHl		;hl=de-hl = left over byte count - PKTLEN
 0260 7D        	mov	a,l		;a=left over count - PKTLEN
 0261 C680      	adi	PKTLEN		;a=left over byte count
 0263 47        	mov	b,a		;b=count of bytes to move
 0264 212B0B    	lxi	h,trkBuf	;hl->start of trkBuf
 0267 CA7202    	jz	mvDone		;no bytes to move, we're done
                
                ; Copy the leftover data backwards to just before the track buffer. The
                ;   next XMODEM send sequence will start at the beginning of this copied
                ;   data instead of at the start of trkBuf.
                
 026A 2B        moveLp	dcx	h		;hl->memory just before trkBuf
 026B 1B        	dcx	d		;de->unsent bytes from end of trkBuf
 026C 1A        	ldax	d		;move from end of trkBuf to before trkBuf
 026D 77        	mov	m,a	
 026E 05        	dcr	b
 026F C26A02    	jnz	moveLp
                
 0272 222109    mvDone	shld	sndPtr		;save address from which to send next time
 0275 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; sndPkt - send an xmodem format 128 byte packet. HL points to the 128 byte
                ;    buffer to send. On exit, HL points to the next 128 byte boundary.
                ;-----------------------------------------------------------------------------
 0276 3E0A      sndPkt	mvi	a,XMTRIES	;init retry counter
 0278 321C09    	sta	xmRetry
                
                ; First, send header bytes
                
 027B CDE103    reSend	call	chkQuit		;check for ctrl-c
 027E E5        	push	h		;save hl for possible re-send
 027F 3E01      	mvi	a,SOH		;1st byte is SOH
 0281 CD8603    	call	sndByte
 0284 3A1D09    	lda	blkNum		;2nd byte is the block number
 0287 CD8603    	call	sndByte
 028A 2F        	cma			;2nd complement of block number
 028B CD8603    	call	sndByte
                
                ; Init checksum and CRC and packet length for transmission of data portion
                
 028E AF        	xra	a		;init crc
 028F 321F09    	sta	crc16
 0292 322009    	sta	crc16+1
 0295 110080    	lxi	d,PKTLEN*256	;d=byte counter, e=0 (checksum)
                
                ; Loop sending the data bytes and updating checksum and CRC
                
 0298 7E        pktLoop	mov	a,m
 0299 CD8603    	call	sndByte		;send and update checksum in e
 029C CD0803    	call	calCrc		;update the CRC
 029F 23        	inx	h		;point to next byte
 02A0 15        	dcr	d		;decrement bytes remaining
 02A1 C29802    	jnz	pktLoop
                
                ; Send checksum or CRC based on crcFlag
                
 02A4 3A1E09    	lda	crcFlag		;crc or checksum?
 02A7 B7        	ora	a
 02A8 CAB702    	jz	sndCsum		;flag clear = checksum
                
 02AB 3A2009    	lda	crc16+1		;a=high byte of CRC
 02AE CD8603    	call	sndByte		;send it
 02B1 3A1F09    	lda	crc16		;a=low byte of crc
 02B4 C3B802    	jmp	sndSkip		;skip next instruction	
                
 02B7 7B        sndCsum	mov	a,e		;send the checksum byte
                
 02B8 CD8603    sndSkip	call	sndByte
                
                ;  All bytes sent. Wait for the response.
                
 02BB 0603      	mvi	b,3		;3 second timeout
 02BD CD8F03    	call	rcvByte		;get the response character
 02C0 CAD102    	jz	sndFail		;timeout on response
                
 02C3 FE06      	cpi	ACK		;ack received?
 02C5 C2D102    	jnz	sndFail		;no, send failed
                
 02C8 3A1D09    	lda	blkNum		;increment block number
 02CB 3C        	inr	a
 02CC 321D09    	sta	blkNum
                
 02CF C1        	pop	b		;remove pushed hl, but don't clobber hl
 02D0 C9        	ret
                
                ; sndFail - ACK not received, decrement retry and try again.
                
 02D1 211C09    sndFail	lxi	h,xmRetry	;point to retry counter
 02D4 35        	dcr	m
 02D5 CAFC02    	jz	xmFail		;retries used up, failed xmodem transfer
                
                ; If we've had 3 NAKs on the 1st packet and CRC is selected, assume
                ;   we took so long to send the 1st packet due to disk retries that
                ;   the receiver has since timed out and switched to checksum
                
 02D8 3A1E09    	lda	crcFlag		;are we in CRC mode
 02DB CAF002    	jz	clrRcv2		;no, ignore the rest of this
                
 02DE 3A1D09    	lda	blkNum		;on block 1?
 02E1 3D        	dcr	a
 02E2 C2F002    	jnz	clrRcv2		;no, go on
                
 02E5 3A1C09    	lda	xmRetry		;failed three times in a row on block 1?
 02E8 D607      	sui	XMTRIES-3
 02EA C2F002    	jnz	clrRcv2		;no
                
 02ED 321E09    	sta	crcFlag		;clear crcFlag to force checksum
                
                ;  clrRcv2 - wait for one second of line clear time and send packet again.
                
 02F0 0601      clrRcv2	mvi	b,1		;1 second timeout
 02F2 CD8F03    	call	rcvByte		;wait for 1 second of clear line
 02F5 C2F002    	jnz	clrRcv2
                
 02F8 E1        	pop	h		;restore pointer to the packet
 02F9 C37B02    	jmp	reSend		;re-send the packet
                
                ;  xmFail - Display failure message then restart program
                
 02FC 219A06    xmFail	lxi	h,mXmdm		;xmodem failure message
 02FF CD4D03    	call	dispMsg
                
 0302 316509    	lxi	sp,ourStk	;initialize stack pointer
 0305 C31701    	jmp	getDrv		;start over asking for drive
                
                ;-----------------------------------------------------------------------------
                ; calCrc - update the 16-bit CRC with one more byte. 
                ;    (Copied from M. Eberhard)
                ; On Entry:
                ;   a has the new byte
                ;   crc16 is current except this byte
                ; On Exit:
                ;   crc16 has been updated
                ;   Trashes a,bc
                ;-----------------------------------------------------------------------------
 0308 D5        calCrc	push	d
 0309 E5        	push	h
 030A 2A1F09    	lhld	crc16		;get CRC so far
 030D AC        	xra	h		;XOR into CRC top byte
 030E 67        	mov	h,a
 030F 012110    	lxi	b,1021h		;bc=CRC16 polynomial
 0312 1608      	mvi	d,8		;prepare to rotate 8 bits
                
                ; do 8 bit shift/divide by CRC polynomial
                
 0314 29        cRotLp	dad	h		;16-bit shift
 0315 D21E03    	jnc	cClr		;skip if bit 15 was 0
 0318 7C        	mov	a,h		;CRC=CRC xor 1021H
 0319 A8        	xra	b
 031A 67        	mov	h,a
 031B 7D        	mov	a,l
 031C A9        	xra	c
 031D 6F        	mov	l,a
 031E 15        cClr	dcr	d
 031F C21403    	jnz	cRotLp		;rotate 8 times
                
                ; save the updated CRC and exit
                
 0322 221F09    	shld	crc16		;save updated CRC
 0325 E1        	pop	h
 0326 D1        	pop	d
 0327 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ;  sndEot - send EOT character and wait for ACK response
                ;-----------------------------------------------------------------------------
 0328 3E0A      sndEot	mvi	a,XMTRIES	;init retry counter
 032A 321C09    	sta	xmRetry
                
 032D 3E04      reEot	mvi	a,EOT
 032F CD8603    	call	sndByte
 0332 0603      	mvi	b,3		;3 second timeout
 0334 CD8F03    	call	rcvByte		;
 0337 CA4003    	jz	eotFail		;timeout
                
 033A FE06      	cpi	ACK		;ack received?
 033C C24003    	jnz	eotFail		;no, eot send failed
                
 033F C9        	ret			;otherwise, we're done.
                
                ; timeout waiting for ACK to EOT. Decrement retry counter and try again
                
 0340 211C09    eotFail	lxi	h,xmRetry	;point to retry counter
 0343 35        	dcr	m
 0344 C22D03    	jnz	reEot
                
                ;just give up - xfer was probably good
                
 0347 21BC06    	lxi	h,mNoAck
 034A C34D03    	jmp	dispMsg
                
                ;-----------------------------------------------------------------------------
                ; dispMsg - display the null-terminated message passed in hl on the
                ;    console device. Clobbers b, hl
                ;-----------------------------------------------------------------------------
 034D 7E        dispMsg	mov	a,m		;get the next message byte
 034E B7        	ora	a		;null terminates
 034F C8        	rz
                
 0350 47        	mov	b,a		;conOut wants character in b
 0351 CDB907    	call	conOut
 0354 23        	inx	h		;move to next byte
 0355 C34D03    	jmp	dispMsg
                
                ;-----------------------------------------------------------------------------
                ; rcvCon - Receive a character from the console device, echo it, then
                ;   wait for a CR. Exits program if Ctrl-c typed. Returns with invalid
                ;   character (null) if BS or DEL pressed after 1st character
                ;   Returns character in a, clobbers b.
                ;-----------------------------------------------------------------------------
 0358 CDB107    rcvCon	call	conIn		;check for input
 035B CA5803    	jz	rcvCon		;nothing
                
 035E E67F      	ani	7fh
 0360 FE03      	cpi	CTRLC		;abort requested?
 0362 CAF003    	jz	pgmExit		;yes
                
 0365 FE0D      	cpi	CR		;return pressed?
 0367 C8        	rz			;yes, don't echo it
                
 0368 47        	mov	b,a		;conOut needs character in b
 0369 CDB907    	call	conOut		;echo it
                
                ; Wait for CR, then return 1st character typed
                
 036C CDB107    rcvCr	call	conIn		;check for input
 036F CA6C03    	jz	rcvCr		;nothing
                
 0372 E67F      	ani	7fh
 0374 FE03      	cpi	CTRLC		;abort requested?
 0376 CAF003    	jz	pgmExit		;yes
                
 0379 FE7F      	cpi	DEL		;delete
 037B C8        	rz			;yes, return DEL character
                
 037C FE08      	cpi	BS		;backspace?
 037E C8        	rz			;yes, return BS character
                
 037F FE0D      	cpi	CR		;return pressed?
 0381 C26C03    	jnz	rcvCr		;no, keep waiting
                
 0384 78        	mov	a,b		;return 1st character typed
 0385 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; sndByte - send the byte in a through the specified transfer port. 
                ;     Adds the byte to register e for checksum. Clobbers b.
                ;     XMODEM send routine assumes serOut returns with a containing
                ;     the character sent.
                ;-----------------------------------------------------------------------------
 0386 47        sndByte	mov	b,a		;b=byte to transmit
 0387 83        	add	e		;update checksum
 0388 5F        	mov	e,a		;e=updated checksum
 0389 3A1B09    	lda	xfrPort		;a=port to use for transfer
 038C C3E407    	jmp	serOut		;send the character
                
                ;-----------------------------------------------------------------------------
                ; rcvByte - Receive a byte from specified transfer port in A with B second
                ;     timeout. If a timeout occurs, zero is returned in A and the zero 
                ;     flag is true. Otherwise, the character is returned in A (could be
                ;     zero) and zero flag is false. ONESEC must be set based on processor
                ;     speed and the number of cycles in the serIn call + 59. 
                ;     Clobbers a, b, d and e.
                ;-----------------------------------------------------------------------------
 038F 111F4B    rcvByte	lxi	d,ONESEC	;de=cycles through this loop for 1s
                
 0392 3A1B09    rcvWait	lda	xfrPort		;(13) a=port to use for transfer
 0395 CDC407    	call	serIn		;(17+cycles in serIn)look for a byte
 0398 C0        	rnz			;(5)byte received
                
 0399 1B        	dcx	d		;(5)otherwise, decrement timer
 039A 7A        	mov	a,d		;(5)one second expire?
 039B B3        	ora	e		;(4)
 039C C29203    	jnz	rcvWait		;(10)no, keep waiting
 039F 05        	dcr	b		;seconds left?
 03A0 C29203    	jnz	rcvWait
                
 03A3 C9        rcvB	ret			;return with timeout (zero true and in a)
                
                ;-----------------------------------------------------------------------------
                ; dspErr - display the current track and sector number which just had
                ;     a read error. If this is the first error on a track, the track
                ;     number is displayed first.
                ;
                ;  on entry:
                ;     e = sector number
                ;-----------------------------------------------------------------------------
 03A4 3A1A09    dspErr	lda	trkErr		;test track error flag
 03A7 B7        	ora	a
 03A8 C2BE03    	jnz	dspSec		;track already displayed, go display sector
                
 03AB 3C        	inr	a		;set track flag non-zero
 03AC 321A09    	sta	trkErr
                
                ; First error on this track. Display "Track xx errors: "
                
 03AF 21FD06    	lxi	h,errTrk	;hl->where to put ascii decimal
 03B2 3A9108    	lda	trkNum		;a=track with error on it
 03B5 CDC903    	call	bin2dec		;track to ascii
 03B8 21F506    	lxi	h,mTrkErr	;display the track error message
 03BB CD4D03    	call	dispMsg
                
                ; dspSec - display the sector number with an error
                
 03BE 211107    dspSec	lxi	h,errSec	;hl->where to put ascii sector
 03C1 7B        	mov	a,e		;a=sector where error occured
 03C2 CDC903    	call	bin2dec
 03C5 CD4D03    	call	dispMsg		;display the error
 03C8 C9        	ret
                
                ;--------------------------------------------------------------
                ; bin2dec - Binary byte in A to 2 ASCII digits at (HL)
                ;   HL is preserved
                ;--------------------------------------------------------------
 03C9 3620      bin2dec	mvi	m,' '		;assume zero supression
 03CB D60A      	sui	10		;value less than 10?
 03CD DADB03    	jc	do1s		;yes, leading blank
 03D0 3631      	mvi	m,'1'		;have one ten already
                
 03D2 D60A      loop10	sui	10		;count 10s
 03D4 DADB03    	jc	do1s		;done with 10s, do 1s
 03D7 34        	inr	m
 03D8 C3D203    	jmp	loop10
                
 03DB C63A      do1s	adi	'0'+10		;form ASCII 1s digit
 03DD 23        	inx	h		;move to 1s position
 03DE 77        	mov	m,a
 03DF 2B        	dcx	h		;restore hl
 03E0 C9        	ret
                
                ;--------------------------------------------------------------
                ; chkQuit - check for the user to request abort (ctrl-c). If
                ;    a character is present on the console port, read it and
                ;    see if ctrl-c. Clobbers A
                ;--------------------------------------------------------------
 03E1 CDB107    chkQuit	call	conIn		;check for console input
 03E4 C8        	rz
                
 03E5 E67F      	ani	7fh
 03E7 FE03      	cpi	CTRLC		;abort requested?
 03E9 C0        	rnz			;no
                
                ; Ctrl-C typed while program is running. Return to drive prompt.
                
 03EA 316509    	lxi	sp,ourStk	;initialize stack pointer
 03ED C31701    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; pgmExit - Exit to CP/M or to the monitor ROM based on the
                ;    CP/M flag
                ;--------------------------------------------------------------
 03F0 3A2309    pgmExit	lda	cpmFlag		;running under CP/M?
 03F3 B7        	ora	a
 03F4 C20004    	jnz	cpmExit		;yes
                
                ; Exit to ROM monitor
                
 03F7 211507    	lxi	h,mExit		;display "exiting" message
 03FA CD4D03    	call	dispMsg
 03FD C30001    	jmp	MONITOR		;jump to ROM monitor entry point
                
                ; CP/M exit. If boot drive was used, prompt user to insert CP/M disk
                
 0400 3A9008    cpmExit	lda	drvNum		;boot drive used?
 0403 D600      	sui	MINDRV
 0405 C21104    	jnz	noDisk		;not 1, disk prompt not needed
                
 0408 212507    	lxi	h,mCpm		;display "insert cp/m disk"	
 040B CD4D03    	call	dispMsg
 040E CD5803    	call	rcvCon		;wait for a character
                
 0411 3E00      noDisk	mvi	a,MINDRV	;re-select drive A for CP/M 1.4
 0413 329008    	sta	drvNum
 0416 CD7108    	call	dSelDrv
                
 0419 211507    	lxi	h,mExit		;display "exiting" message
 041C CD4D03    	call	dispMsg
 041F C30000    	jmp	CPMBOOT		;reboot CP/M
                
                ;--------------------------------------------------------------
                ; chkCpm - check if running under CP/M. CP/M flag is set true
                ;   (non-zero) if yes, cleared otherwise.
                ;--------------------------------------------------------------
                ; First, initialize entries for stand-alone
                
 0422 AF        chkCpm	xra	a
 0423 322309    	sta	cpmFlag		;clear CP/M flag
 0426 3E30      	mvi	a,MINDRV+'0'	;ascii for minimum drive number
 0428 32A105    	sta	mDrvMin		;store in the drive prompt message
 042B 322409    	sta	baseDrv		;ascii 1st drive - baseDrv = 0
 042E 3E33      	mvi	a,MAXDRV+'0'	;ascii for max drive number
 0430 32A305    	sta	mDrvMax
                
                ; Determine if we're under CP/M or standalone. CP/M is assumed if
                ;   a jump instruction is present at the CP/M warm start location (0)
                ;   and five more jumps (e.g., a jump table) is present at the
                ;   jump-to destination.
                		
 0433 3A0000    	lda	WBOOT		;see if jump instruction present for CP/M
 0436 FEC3      	cpi	JMPINST
 0438 C0        	rnz			;no, not CP/M
                
                ; A jump instruction is present at the CP/M warm boot location (0),
                ;   now see if that jump points to five more jumps. If so, assume CP/M
                
 0439 210100    	lxi	h,WBOOT+1	;point to lsb of jump address
 043C 5E        	mov	e,m		;e=low byte of jump
 043D 23        	inx	h
 043E 56        	mov	d,m		;de=destination of jump
 043F 0605      	mvi	b,5		;look for 5 more jumps (a jump table)
                
 0441 1A        jmpTest	ldax	d		;a=opcode at jump destination
 0442 D6C3      	sui	JMPINST		;another jump present?
 0444 C0        	rnz			;no, not CP/M
 0445 13        	inx	d		;move to next jump
 0446 13        	inx	d
 0447 13        	inx	d
 0448 05        	dcr	b
 0449 C24104    	jnz	jmpTest
                
 044C 3D        	dcr	a		;a=0ffh
 044D 322309    	sta	cpmFlag		;CP/M flag to non-zero = true
                
                ; We're running under CP/M. Change drive prompt message to show drive
                ;    letters instead of drive numbers and change baseDrv to convert
                ;    an 'A' to the base drive number (MINDRV).
                
 0450 3E41      	mvi	a,'A'		;'A' in drive message instead of number
 0452 32A105    	sta	mDrvMin
 0455 C603      	adi	MAXDRV-MINDRV	;max drive letter
 0457 32A305    	sta	mDrvMax
 045A 3E61      	mvi	a,'a'		;ascii 1st drive - baseDrv = 0
 045C 322409    	sta	baseDrv
 045F C9        	ret
                
                ;------------------------------------------------------------------
                ; sizeRam - determine how much RAM we have for buffering tracks.
                ;   Sets the bufEnd variable which points to end address of 
                ;   the last possible track buffer + 1
                ;------------------------------------------------------------------
                ; If running under CP/M, use the BIOS pointer to determine the top
                ;    of available RAM. Otherwise, size RAM manually.
                
 0460 2A0100    sizeRam	lhld	WBOOT+1		;get address of BIOS jump table+3
 0463 2B        	dcx	h		
 0464 2B        	dcx	h
 0465 2B        	dcx	h		;hl->top of usable ram+1
 0466 3A2309    	lda	cpmFlag		;running under CP/M?
 0469 B7        	ora	a
 046A C27B04    	jnz	ramEnd		;yes, we have the end of RAM
                
                ;  Not under CP/M. Find the end of RAM manually.
                
 046D 21000C    	lxi	h,(trkBuf+0ffh) AND 0ff00h   ;next 256 byte boundary
                
 0470 7E        ramLoop	mov	a,m		;a=current RAM content
 0471 34        	inr	m		;change RAM
 0472 BE        	cmp	m		;did RAM change?
 0473 77        	mov	m,a		;restore RAM
 0474 CA7B04    	jz	ramEnd		;end of RAM found
                
 0477 24        	inr	h		;next page
 0478 C27004    	jnz	ramLoop
                
                ; ramEnd - end of RAM found. Now determine the end address + 1 of the
                ;   last track buffer that will fit in RAM. Store in bufEnd
                
 047B EB        ramEnd	xchg			;de=end of RAM + 1
 047C 3EF2      	mvi	a,-((TRKLEN SHR 8) + 1) AND 0ffh
 047E BA        	cmp	d		;force de < (10000h - TRKLEN)
 047F D28304    	jnc	topOk
                
 0482 57        	mov	d,a		;limit max address
                
 0483 212B0B    topOk	lxi	h,trkBuf	;hl=start of track buffer
 0486 01000D    	lxi	b,TRKLEN	;bc=length of track in bytes
                
                ; Loop increasing hl by TRKLEN until hl > end of RAM.
                
 0489 09        bfEndLp	dad	b		;hl=hl+track length
 048A CD9C04    	call	cmpHlDe		;compare hl-de
 048D DA8904    	jc	bfEndLp		;still more room, keep going
                
                ; Subtrack three track lengths from hl, this will be the end address + 1 of
                ;   the last track buffer that will fit in RAM
                
 0490 0100D9    	lxi	b,-TRKLEN*3	;subtract three track lengths
 0493 09        	dad	b
 0494 01000C    	lxi	b,XTRALEN	;room for 50 sector track 1
 0497 09        	dad	b		;hl = end address of last track + 1
 0498 229608    	shld	bufEnd		;save as bufEnd
 049B C9        	ret
                
                ;--------------------------------------------------------------------
                ; cmHlDe - compare HL-DE. Carry set if HL<DE, carry clear if HL>=DE
                ;--------------------------------------------------------------------
 049C 7D        cmpHlDe	mov	a,l		;compare HL-DE, do lsbs first
 049D 93        	sub	e
 049E 7C        	mov	a,h		;do msbs
 049F 9A        	sbb	d
 04A0 C9        	ret			;carry set HL<DE, clear HL>=DE
                
                ;--------------------------------------------------------------------
                ; cmDeHl - compare DE-HL. Carry set if DE<HL, carry clear if DE>=HL
                ;--------------------------------------------------------------------
 04A1 7B        cmpDeHl	mov	a,e		;compare DE-HL, do lsbs first
 04A2 95        	sub	l
 04A3 7A        	mov	a,d		;do msbs
 04A4 9C        	sbb	h
 04A5 C9        	ret			;carry set DE<HL, clear DE>=HL
                
                ;--------------------------------------------------------------------
                ; subDeHl - HL=DE-HL
                ;--------------------------------------------------------------------
 04A6 7B        subDeHl	mov	a,e		;subtract DE-HL, do lsbs first
 04A7 95        	sub	l
 04A8 6F        	mov	l,a		;lsb result in l
 04A9 7A        	mov	a,d		;do msbs
 04AA 9C        	sbb	h
 04AB 67        	mov	h,a		;msb result in h	
 04AC C9        	ret
                
                ;--------------------------------------------------------------------
                ; delayMs - delay number of MS specified in A. Clobbers B.
                ;    Be sure to set the ONEMS equate as required for the
                ;    target CPU.
                ;--------------------------------------------------------------------
 04AD 0669      delayMs	mvi	b,ONEMS		;loops for 1ms
                	
 04AF 00        dlyLoop	nop			;(4)
 04B0 05        	dcr	b		;(5 or 4)
 04B1 C2AF04    	jnz	dlyLoop		;(10)
                
 04B4 3D        	dcr	a		;decrement ms counter
 04B5 C2AD04    	jnz	delayMs
                
 04B8 C9        	ret
                
                ;---------------------------------------------------------------------
                ; Message constants
                ;---------------------------------------------------------------------
 04B9 0D0A0A    mWelcom	db	cr,lf,lf
 04BC 3D3D3D3D3D	db	'===== Floppy to PC Disk Image Transfer =====',cr,lf
 04EA 2020202020	db	'       (Tarbell Controller, ver 1.1)',cr,lf,lf
 0511 53656E6473	db	'Sends an image of a SSSD 8" floppy to a PC via an 88-2SIO'
 054A 0D0A      	db	cr,lf
 054C 6F72203838	db	'or 88-SIO serial port using the XMODEM protocol.',0
                
 057D 0D0A0A496EmDrive	db	cr,lf,lf,'Insert and specify source drive ('
 05A1 782D      mDrvMin	db	'x-'
 05A3 7829206F72mDrvMax	db	'x) or X to exit: ',0
                
 05B5 0D0A0A    mPort	db	cr,lf,lf
 05B8 5370656369	db	'Specify the port to use for file transfer',cr,lf
 05E3 2020312920	db	'  1) 88-2SIO port A (which is also the console)',cr,lf
 0614 2020322920	db	'  2) 88-2SIO port B',cr,lf
 0629 2020332920	db	'  3) 88-SIO',cr,lf
 0636 456E746572	db	'Enter 1-3 or X to exit: ',0
                
 064F 0D0A0A5374mStart	db	cr,lf,lf,'Start XMODEM receive operation on the PC now...',0
                
 0682 0D0A0A5472mDone	db	cr,lf,lf,'Transfer complete!',cr,lf,0
                
 069A 0D0A0A584DmXmdm	db	cr,lf,lf,'XMODEM communication failure',cr,lf,0
                
 06BC 0D0A0A4E6FmNoAck	db	cr,lf,lf,'No ACK received on EOT.',cr,lf,0
                
 06D9 0D0A0A5365mNoTrk0	db	cr,lf,lf,'Seek to track 0 failed',cr,lf,0
                
 06F5 0D0A547261mTrkErr	db	cr,lf,'Track '
 06FD 7878206661errTrk	db	'xx failed sectors: ',0
 0711 78782000  errSec	db	'xx ',0
                
 0715 0D0A0A4578mExit	db	cr,lf,lf,'Exiting...',cr,lf,0
                
 0725 0D0A0A    mCpm	db	cr,lf,lf
 0728 496E736572	db	'Insert CP/M disk into drive A, then press Return...',0
                
 075C 0D0A0A4443mDDTO	db	cr,lf,lf,'DCM command timeout. Is DCM running?',cr,lf,0
                
 0786 0D0A0A4472mDNR	db	cr,lf,lf,'Drive Not Ready',cr,lf,0
                
                ;****************************************************************************
                ;
                ;  Hardware specific console and serial I/O routines. 
                ;     The following four routines must be written to provide a common
                ;     interface to the hardware on which this program is running. The
                ;     port number specified for serIn and serOut matches the port number
                ;     input from the operator via the port menu.
                ;
                ;****************************************************************************
                
                ; 88-2SIO Serial Board Equates
                
 0010 =         s2aCtl	equ	010h		;1st port on 88-2SIO board - control register
 0011 =         s2aDat	equ	011h		;1st port on 88-2SIO board - data register
 0012 =         s2bCtl	equ	012h		;2nd port on 88-2SIO board - control register
 0013 =         s2bDat	equ	013h		;2nd port on 88-2SIO board - data register
 0001 =         s2Rdrf	equ	001h		;read data register full flag
 0002 =         s2Tdre	equ	002h		;transmit data register empty flag
 0003 =         s2Rst	equ	003h		;reset command
 0015 =         s28n1	equ	015h		;8N1 selection
 0011 =         s28n2	equ	011h		;8N2 selection
                
                ; 88-SIO Serial board Equates
                
 0000 =         sioCtl	equ	00h		;control port
 0001 =         sioDat	equ	01h		;data port
 0001 =         sioRdrf	equ	00000001b	;-RX Data register full
 0080 =         sioTdre	equ	10000000b	;-TX Data register empty
                
                ; The rcvByte subroutine above times a one second timeout with a code
                ;    loop that calls the hardware specific serIn routine below. ONESEC
                ;    must be set based on processor speed and the number of cycles in 
                ;    the serIn call + 59 cycles for the rcvByte code. 
                
 4B1F =         ONESEC	equ	19231		;rcvByte loop count for 1 second
                
                ;----------------------------------------------------------------------------
                ; s2Init - reset and initialize 88-2SIO ports for 8N1
                ;----------------------------------------------------------------------------
 079B 3E03      s2Init	mvi	a,s2Rst		;reset and init 2nd 88-2SIO port
 079D D312      	out	s2bCtl
 079F 3E15      	mvi	a,s28n1		;transfer port as 8N1
 07A1 D312      	out	s2bCtl
                
                ; if not running under CP/M, reset and init 1st 88-2SIO port
                
 07A3 3A2309    	lda	cpmFlag		;running under CP/M?
 07A6 B7        	ora	a
 07A7 C0        	rnz			;yes, 2SIO already initialized
                
 07A8 3E03      	mvi	a,s2Rst		;reset and init 1st 88-2SIO port
 07AA D310      	out	s2aCtl
 07AC 3E11      	mvi	a,s28n2		;configure console for 8N2 in case Teletype
 07AE D310      	out	s2aCtl
 07B0 C9        	ret	
                
                ;----------------------------------------------------------------------------
                ; conIn - input character from console
                ;    inputs:
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ;    clobbers none
                ;----------------------------------------------------------------------------
 07B1 DB10      conIn	in	s2aCtl		;see if a new character is present
 07B3 E601      	ani	s2Rdrf
 07B5 C8        	rz			;no character, return zero status
                
 07B6 DB11      	in	s2aDat		;return character and non-zero status
 07B8 C9        	ret	
                
                ;----------------------------------------------------------------------------
                ; conOut - output character to console
                ;    inputs: b = character to send
                ;    clobbers a
                ;----------------------------------------------------------------------------
 07B9 DB10      conOut	in	s2aCtl		;wait for OK to transmit
 07BB E602      	ani	s2Tdre
 07BD CAB907    	jz	conOut
 07C0 78        	mov	a,b		;a=character to transmit
 07C1 D311      	out	s2aDat		;send it
 07C3 C9        	ret
                
                ;----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serIn - input character from port specified in a
                ;       0 = 88-2SIO port A
                ;       1 = 88-2SIO port B
                ;       2 = 88-SIO
                ;    inputs: a = port to read from
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ;    clobbers none
                ; 88-2SIO Port A: 53 cycles including return when no character present
                ; 88-2SIO Port B: 43 cycles including return when no character present
                ; 88-SIO: 57 cycles including return when no character present
                ;-----------------------------------------------------------------------------
 07C4 3D        serIn	dcr	a		;(5)3-way test
 07C5 CAD307    	jz	s2InB		;(10)a was 1: 88-2SIO port B
 07C8 F2DB07    	jp	sioIn		;(10)a was 2: 88-SIO
                				;    a was 0: 88-2SIO port A
                ; Input from 88-2SIO port A
                
 07CB DB10      s2InA	in	s2aCtl		;(10+1)see if a new character is present
 07CD E601      	ani	s2Rdrf		;(7)
 07CF C8        	rz			;(10)no character, return zero status
 07D0 DB11      	in	s2aDat		;return character and non-zero status
 07D2 C9        	ret	
                	
                ; Input from 88-2SIO port B
                
 07D3 DB12      s2InB	in	s2bCtl		;(10+1)see if a new character is present
 07D5 E601      	ani	s2Rdrf		;(7)
 07D7 C8        	rz			;(10)no character, return zero status
                
 07D8 DB13      	in	s2bDat		;return character and non-zero status
 07DA C9        	ret	
                
                ; Input from 88-SIO
                
 07DB DB00      sioIn	in	sioCtl		;(10+1)see if a new character is present
 07DD 2F        	cma			;(4)invert Rx Data Ready flag
 07DE E601      	ani	sioRdrf		;(7)
 07E0 C8        	rz			;(10)no character, return zero status
                
 07E1 DB01      	in	sioDat		;return character and non-zero status
 07E3 C9        	ret	
                
                ;-----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serOut - output character to port specified in a
                ;       0 = 88-2SIO port A
                ;       1 = 88-2SIO port B
                ;       2 = 88-SIO
                ;    inputs: a = port to transmit through
                ;	     b = character to send
                ;    clobbers a
                ;-----------------------------------------------------------------------------
 07E4 3D        serOut	dcr	a		;3-way test
 07E5 CAF607    	jz	s2OutB		;a was 1: 88-2SIO port B
 07E8 F20108    	jp	sioOut		;a was 2: 88-SIO
                				;a was 0: 88-2SIO port A
                
                ; Send character through 88-2SIO port A
                
 07EB DB10      S2OutA	in	s2aCtl		;wait for OK to transmit
 07ED E602      	ani	s2Tdre
 07EF CAEB07    	jz	S2OutA
                
 07F2 78        	mov	a,b		;a=character to transmit
 07F3 D311      	out	s2aDat		;send it
 07F5 C9        	ret
                
                ; Send character through 88-2SIO port B
                
 07F6 DB12      s2OutB	in	s2bCtl		;wait for OK to transmit
 07F8 E602      	ani	s2Tdre
 07FA CAF607    	jz	s2OutB
                
 07FD 78        	mov	a,b		;a=character to transmit
 07FE D313      	out	s2bDat		;send it
 0800 C9        	ret
                
                ; Send character through 88-SIO
                
 0801 DB00      sioOut	in	sioCtl		;wait for OK to transmit
 0803 E680      	ani	sioTdre
 0805 C20108    	jnz	sioOut		;active-low flag
                
 0808 78        	mov	a,b		;a=character to transmit
 0809 D301      	out	sioDat		;send it
 080B C9        	ret
                
                
                ;****************************************************************************
                ;
                ; JADE Double D disk I/O routines
                ;
                ;****************************************************************************
                
                ;--------------------------------------------------------------
                ; dRead - Read sector on current track.
                ; On Entry:
                ;    Drive is selected, on proper track, head loaded
                ;    hl->sector buffer
                ;    e = sector number to read
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;    clobbers h,l
                ;--------------------------------------------------------------
 080C D5        dRead:	push	d		;save d
 080D 7B        	mov	a,e		;set sector
 080E CDAB0A    	call	SETSEC
 0811 3E01      	mvi	a,DCM$RDS	;dcm read sector
 0813 CDDA0A    	call	DSK$EX		;execute on dd
 0816 C22808    	jnz	dRdone		;exit if error
                
 0819 E5        	push	h		;save dest buffer
 081A 018000    	lxi	b,DD$BFL	;number of bytes to move
 081D 2A4000    	lhld	D$ADDR		;dd memory address
 0820 118003    	lxi	d,DD$BUF	;sector buffer offset
 0823 19        	dad	d		;hl now pts sector buf
 0824 D1        	pop	d		;restore dest buffer
 0825 CD0D0B    	call	BLK$MV		;perform block move
                
 0828 D1        dRdone	pop	d		;restore d
 0829 AF        	xra	a		;clear error
 082A C9        	ret			;error return
                
                ;--------------------------------------------------------------
                ; dVerify - Verify sector on current track. The track is
                ;    read to verify CRC, but not compared
                ; On Entry:
                ;    Drive is selected, on proper track, head loaded
                ;    e = sector number to verify
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;    clobbers none
                ;--------------------------------------------------------------
 082B 219808    dVerify	lxi	h,secBuf	;hl=sector buffer, e=sector
 082E C30C08    	jmp	dRead		;read sector
                
                
                ;--------------------------------------------------------------
                ; dWrite - Write a sector on current track
                ; On Entry:
                ;    Drive is selected, on proper track, head loaded
                ;    hl->buffer address
                ;    e = sector number to write
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;   clobbers h,l
                ;--------------------------------------------------------------
 0831 D5        dWrite:	push	d		;save d
 0832 7B        	mov	a,e
 0833 CDAB0A    	call	SETSEC
 0836 E5        	push	h		;save source buffer
 0837 018000    	lxi	b,DD$BFL	;number of bytes to move
 083A 2A4000    	lhld	D$ADDR		;DD memory address
 083D 118003    	lxi	d,DD$BUF	;sector buffer offset
 0840 19        	dad	d		;hl now pts cmnd blk
 0841 EB        	xchg
 0842 E1        	pop	h		;restore source buffer
 0843 CD0D0B    	call	BLK$MV		;perform block move
                	
                ;*******( PERFORM WRITE SECTOR )***********************
                
 0846 3E02      	mvi	a,DCM$WRS	;DCM write sector
 0848 CDDA0A    	call	DSK$EX		;execute
 084B D1        	pop	d		;restore d
 084C C9        	ret			;return A if error
                	
                ;--------------------------------------------------------------
                ; dSeek - Seek track specified in L. Selects drive and loads
                ;    head. If the head was not already loaded, then the E bit
                ;    (wait for head settle one-shot) is set in fWaitHd for
                ;    OR'ing into the subsequent read/write command.
                ; On Entry:
                ;    l = desired track
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ; Clobbers none
                ;--------------------------------------------------------------
 084D F5        dSeek	push	a
 084E 7D        	mov	a,l		;set track number
 084F CD9A0A    	call	SETTRK
 0852 F1        	pop	a
 0853 C9        	ret			;Jade DD will seek on write
                
                
                ;--------------------------------------------------------------
                ; dRestor - Selects drive, loads heads and restores to track 0.
                ;    If restore fails, message display and program restarted
                ;    at getDrv.
                ; On Entry:
                ;    drvNum = drive to be selected and restored to track zero
                ; On Exit:
                ;    drive selected and on track zero
                ; Clobbers a
                ;--------------------------------------------------------------
 0854 CD7108    dRestor	call	dSelDrv		;make sure drive is selected
                
 0857 AF        	xra	a		;Track 0 / Sector 1
 0858 32250B    	sta	DCM$TRK
 085B 3C        	inr	a
 085C 32260B    	sta	DCM$SEC
                
 085F 3E00      	mvi	a,DCM$LOG	;logon command seeks to track 0
 0861 CDDA0A    	call	DSK$EX		;Z clear and error in A
 0864 C8        	rz			;success
                
                ; restore failed
                
 0865 21D906    	lxi	h,mNoTrk0
                
 0868 CD4D03    errMsg	call	dispMsg
 086B 316509    	lxi	sp,ourStk	;initialize stack pointer
 086E C31701    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; dSelDrv - Select and wait for drive specified in drvNum 
                ;    to be ready.
                ; On Entry:
                ;    drvNum = drive to be selected
                ; On Exit:
                ;    drive selected and ready, 1771 not busy
                ; Clobbers a
                ;--------------------------------------------------------------
 0871 3A9008    dSelDrv	lda	drvNum		;a=desired drive
 0874 CD960A    	call	SETDRV
 0877 C9        	ret
                
                ;--------------------------------------------------------------
                ; dNxtSec - wait for next (any) sector. For the 1771, this
                ;    routine simply increments and wraps the sector number
                ;    passed in e, then falls into dWtSec to return bc with
                ;    the offset of the sector within the track buffer.
                ; On Entry:
                ;    Drive is selected, motor is running
                ;    e = most recent sector number
                ; On Exit:
                ;    e = next sector sector number
                ;    bc = byte offset of this sector in a track
                ;--------------------------------------------------------------
 0878 1C        dNxtSec	inr	e		;move to next staggered sector
 0879 1C        	inr	e		;skew of 2
                
 087A 3A9208    	lda	numSecs
 087D 47        	mov	b,a
 087E 04        	inr	b
 087F 7B        	mov	a,e		;see if past end
 0880 B8        	cmp	b		;verify between 1 and 26/50
 0881 DA8608    	jc	dWtSec		;good sector, compute bc
                
 0884 1E01      dSec1	mvi	e,1		;restart at sector 1
                				;fall into dWtSec
                
                ;--------------------------------------------------------------
                ; dWtSec - wait for sector specified in e. For the DD
                ;    controller, this routine simply returns the offset
                ;    of the sector within this track in bc.
                ; On Entry:
                ;    Drive is selected, motor is running
                ;    e = desired sector number (must be 1-50 for DD)
                ; On Exit:
                ;    e = sector number
                ;    bc = byte offset of this sector in a track
                ;--------------------------------------------------------------
 0886 7B        dWtSec	mov	a,e		;save the computed sector
                
                ; compute bc=128*(sector-1)
                
 0887 D601      	sui	1		;zero index and clear carry
 0889 1F        	rar
 088A 47        	mov	b,a		;b=sector >> 1
                
 088B 1F        	rar			;put lsbit into msbit	
 088C E680      	ani	80h
 088E 4F        	mov	c,a		;bc=128*e
 088F C9        	ret
                
                
                ;**************************************************************************
                ; 
                ;  Data area
                ;
                ;**************************************************************************
                ; disk variables
                
 0890           drvNum	ds	1		;drive number to use
 0891           trkNum	ds	1		;track number to read
 0892           numSecs	ds	1		;number of sectors in track
 0893           fWaitHd	ds	1		;E bit (wait head settle) flag
 0894           trkPtr	ds	2		;pointer into trkBuf at track boundaries
 0896           bufEnd	ds	2		;end address + 1 of last track spot in RAM
 0898           secBuf	ds	SECLEN		;sector buffer for reads
                
                ; retry logic variables
                
 0918           rdRtry	ds	1		;disk read retry counter
 0919           rtStep	ds	1		;current retry step
 091A           trkErr	ds	1		;non zero if error occured on track
                
                ; xmodem variables
                
 091B           xfrPort	ds	1		;pseudo port for file transfer
 091C           xmRetry	ds	1		;xmodem retry counter
 091D           blkNum	ds	1		;current xmodem block number
 091E           crcFlag	ds	1		;non zero if using CRC instead of checksum
 091F           crc16	ds	2		;crc-16 result
 0921           sndPtr	ds	2		;pointer for start of XMODEM send
                
                ; misc variables
                
 0923           cpmFlag	ds	1		;non-zero if running under CP/M
 0924           baseDrv	ds	1		;ascii 1st drive - baseDrv = 0
 0925           	ds	64		;stack space
 0965 =         ourStk	equ	$
                
                ; track buffer runs from here to the end of memory
                
 0965           	ds	PKTLEN		;space for pre-pended unsent data
                
                ;------------------------------------------------------------------------------
                ; PR$NIB - DISPLAY VALUE IN A AS A SINGLE DIGIT ASCII-HEXIDECIMAL VALUE.
                ;------------------------------------------------------------------------------
 09E5 F5        PR$NIB:	PUSH	PSW
 09E6 C5        	PUSH	B
                
 09E7 FE0A      	CPI	10		;GREATER THAN 9?
 09E9 DAEE09    	JC	NIBOUT		;0-9
 09EC C607      	ADI	007H
                
 09EE C630      NIBOUT	ADI	'0'
 09F0 47        	MOV	B,A
 09F1 CDB907    	CALL	conOut
                
 09F4 C1        	POP	B
 09F5 F1        	POP	PSW
                
 09F6 C9        	RET
                
                ;------------------------------------------------------------------------------
                ; PR$BYT - DISPLAY VALUE IN A AS A TWO DIGIT ASCII-HEXIDECIMAL VALUE.
                ; CLOBBERS NONE.
                ;------------------------------------------------------------------------------
 09F7 F5        PR$BYT	PUSH	A
 09F8 C5        	PUSH	B
 09F9 47        	MOV	B,A		;STORE VALUE IN B
 09FA E6F0      	ANI	0F0H		;HIGH NIBBLE
 09FC 0F        	RRC
 09FD 0F        	RRC
 09FE 0F        	RRC
 09FF 0F        	RRC
 0A00 CDE509    	CALL	PR$NIB		;PRINT THE 16'S DIGIT
                
 0A03 78        	MOV	A,B
 0A04 E60F      	ANI	0FH
 0A06 CDE509    	CALL	PR$NIB		;PRINT THE 1'S DIGIT
 0A09 C1        	POP	B
 0A0A F1        	POP	A
 0A0B C9        	RET
                
                ;------------------------------------------------------------------------------
                ; PR$WRD - DISPLAY VALUE IN HL AS A FOUR DIGIT ASCII-HEXIDECIMAL VALUE.
                ; CLOBBERS NONE
                ;------------------------------------------------------------------------------
 0A0C E5        PR$WRD	PUSH	H		;SAVE HL
 0A0D C5        	PUSH	B		;SAVE BC
 0A0E F5        	PUSH	PSW		;SAVE AF
 0A0F 7C        	MOV	A,H		;STORE MSB IN A
 0A10 CDF709    	CALL	PR$BYT		;PRINT MSB
                
 0A13 7D        	MOV	A,L		;STORE LSB IN A
 0A14 CDF709    	CALL	PR$BYT		;PRINT LSB
 0A17 F1        	POP	PSW
 0A18 C1        	POP	B
 0A19 E1        	POP	H
 0A1A C9        	RET
                
                ;******************************************************
                ;********                                     *********
                ;********  JADE DOUBLE D ROUTINES START HERE  *********
                ;********                                     *********
                ;******************************************************
                
                ;******************************************************
                ; SET DOUBLE D SYSTEM PORT ADDRESS		      *
                ;******************************************************
                
 0043 =         D$PORT	EQU	043H	;DOUBLE D PORT ADDRESS.
                
                ;*******( SET USER DOUBLE D BOARD REVISION )***********
                
 0001 =         TRUE	EQU	1	;SET TRUE TO LOGIC ONE.
 0000 =         FALSE	EQU	0	;SET FALSE TO LOGIC ZERO
 0000 =         REV$B	EQU	FALSE	;SET TRUE FOR REV B BOARDS.
 0001 =         REV$C	EQU	TRUE	;SET TRUE FOR REV C BOARDS.
 0000 =         MA10	EQU	FALSE	;TRUE IF MA10 JUMPED (REV-B).
                
                ;*******( DEFINE HALT MASK AND BASE ADDRESS)***********
                
                	IF	REV$B
                DS$HLT	EQU	002H	;STATUS PORT HALT INDICATOR.
                DS$ASW	EQU	00CH	;STATUS PORT ADDR SW MASK.
                D$BASE	EQU	0E400H	;SYSTEM WINDOW BASE ADDRESS
                	ENDIF
                
                	IF	MA10
                D$BASE	EQU	0E000H	;SYSTEM WINDOW BASE ADDRESS
                	ENDIF
                
                	IF	REV$C
 0001 =         DS$HLT	EQU	001H	;STATUS PORT HALT INDICATOR.
 000E =         DS$ASW	EQU	00EH	;STATUS PORT ADDR SW MASK.
 E000 =         D$BASE	EQU	0E000H	;SYSTEM WINDOW BASE ADDRESS
                	ENDIF
                
                ;*******( BOOTSTRAP LINKAGE ADDRESS )******************
                
 0040 =         D$ADDR	EQU	0040H	;DOUBLE D ADDRESS POINTER.
 0042 =         D$MASK	EQU	0042H	;DOUBLE D HALT BIT ADDR.
                
                ;*******( DCM HARDWARE COMMANDS )**********************
                
 0080 =         DC$BGN	EQU	080H	;RESET Z80A AND EXECUTE.
 0001 =         DC$MRQ	EQU	001H	;REQUEST MEMORY WINDOW.
 0000 =         DC$MRT	EQU	000H	;RELEASE MEMORY WINDOW.
 0001 =         DC$MB0	EQU	001H	;SELECT MEMORY BANK 0.
 0003 =         DC$MB1	EQU	003H	;SELECT MEMORY BANK 1.
 0002 =         DC$EXC	EQU	002H	;ISSUE DOUBLE D INTERRUPT.
                
                ;*******( DCM MEMORY ADDRESSES DEFINED )***************
                
 0370 =         DD$CBT	EQU	0370H	;COMMAND BLOCK  (BANK 0).
 0380 =         DD$BUF	EQU	0380H	;SECTOR BUFFER  (BANK 0).
 0080 =         DD$BFL	EQU	128	;SECTOR BUFFER LENGTH.
 0300 =         DD$FBF	EQU	0300H	;FORMAT BUFFER	(BANK 1).
 0100 =         DD$FBL	EQU	0100H	;FORMAT BUFFER LENGTH.
 03A0 =         DD$DPB	EQU	03A0H	;ID SEC DPB	(BANK 0).
 03B1 =         DD$DDF	EQU	03B1H	;ID SEC FLAGS	(BANK 0).
                
                ;*******( DCM COMMANDS )*******************************
                
 0000 =         DCM$LOG	EQU	000H	;LOG ON DISKETTE.
 0001 =         DCM$RDS	EQU	001H	;READ SECTOR.
 0002 =         DCM$WRS	EQU	002H	;WRITE SECTOR.
 0003 =         DCM$FMT	EQU	003H	;FORMAT TRACK.
 0004 =         DCM$ADR	EQU	004H	;ADDRESS.
 0005 =         DCM$LST	EQU	005H	;LIST CHARACTER.
 0006 =         DCM$LCK	EQU	006H	;LIST STATUS.
 0007 =         DCM$IDL	EQU	007H	;IDLE.
                
                ;*******( STATUS BIT DEFINITIONS )*********************
                
 0080 =         ST$DNR	EQU	080H	;DRIVE NOT READY
 0040 =         ST$WRP	EQU	040H	;WRITE PROTECTED
 0020 =         ST$BT5	EQU	020H	;NOT ASSIGNED
 0010 =         ST$RNF	EQU	010H	;RECORD NOT FOUND
 0008 =         ST$CRC	EQU	008H	;CRC ERROR
 0004 =         ST$LDE	EQU	004H	;LOST DATA ERROR
 0002 =         ST$HME	EQU	002H	;DRIVE HOME ERROR
 0001 =         ST$TSD	EQU	001H	;TWO SIDES FLAG (FORMAT)
 0000 =         ST$NOE	EQU	000H	;NO ERROR
                
                ;******************************************************
                ; INIT DOUBLE D AND EXECUTE LOGON COMMAND	      *
                ;******************************************************
                
 0A1B DB43      INI$DD:	IN	D$PORT		;INPUT STATUS PORT.
 0A1D E60E      	ANI	DS$ASW		;MASK FOR ADDR SWS.
 0A1F 07        	RLC			;POSITION BITS.
 0A20 F6E0      	ORI     D$BASE SHR 8	;OR IN BASE ADDR.
 0A22 67        	MOV	H,A		;HIGH BYTE VALUE.
 0A23 2E00      	MVI	L,0		;LOW BYTE VALUE.
 0A25 224000    	SHLD    D$ADDR		;STORE THE ADDRESS
                
 0A28 3E01      	MVI	A,DS$HLT	;LOAD HALT BIT MASK.
 0A2A 324200    	STA	D$MASK		;STORE FOR BIOS USE.
                
 0A2D 3A9008    	LDA	drvNum		;SET DRIVE NUMBER
 0A30 32240B    	STA	DCM$DRV
                
 0A33 AF        	XRA	A		;SET TRACK NUMBER
 0A34 32250B    	STA	DCM$TRK
                
 0A37 3C        	INR	A		;SET SECTOR NUMBER
 0A38 32260B    	STA	DCM$SEC
                	
 0A3B 78        	MOV	A,DCM$LOG	;TRY THE LOGON COMMAND
 0A3C CDDA0A    	CALL	DSK$EX		;Z CLEAR AND ERROR IN A
                
 0A3F C9        	RET
                
                ;******************************************************
                ; PUT DCM DISK BUFFER FROM SOURCE IN HL		      *
                ;******************************************************
                
 0A40 3E01      PUT$DB:	MVI	A,DC$MB0	;REQUEST BANK 0
 0A42 D343      	OUT	D$PORT
                
 0A44 EB        	XCHG			;HL TO DE
 0A45 018000    	LXI	B,DD$BFL	;NMBR BYTE TO MOVE.
 0A48 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0A4B 117003    	LXI	D,DD$CBT	;COMMAND BYTE OFFSET.
 0A4E 19        	DAD	D		;HL NOW PTS CMND BLK.
 0A4F EB        	XCHG			;HL=SRC DE=SEC BUF
 0A50 CD0D0B    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
 0A53 C9        	RET
                
                ;******************************************************
                ; GET DCM DISK BUFFER AND STORE IN HL		      *
                ;******************************************************
                
 0A54 3E01      GET$DB:	MVI	A,DC$MB0	;REQUEST BANK 0
 0A56 D343      	OUT	D$PORT
                
 0A58 EB        	XCHG			;HL TO DE
 0A59 018000    	LXI	B,DD$BFL	;NMBR BYTE TO MOVE.
 0A5C 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0A5F 117003    	LXI	D,DD$CBT	;COMMAND BYTE OFFSET.
 0A62 19        	DAD	D		;HL NOW PTS CMND BLK.
 0A63 CD0D0B    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
 0A66 C9        	RET
                
                ;******************************************************
                ; GET DCM CONTROL BLOCK  			      *
                ;******************************************************
                
 0A67 3E01      GET$CB:	MVI	A,DC$MB0	;REQUEST BANK 0
 0A69 D343      	OUT	D$PORT
                
 0A6B 010800    	LXI	B,8		;NMBR BYTE TO MOVE.
 0A6E 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0A71 117003    	LXI	D,DD$CBT	;COMMAND BYTE OFFSET.
 0A74 19        	DAD	D		;HL NOW PTS CMND BLK.
 0A75 11230B    	LXI	D,DCM$CMD	;JDDUTIL CMND BLOCK.
 0A78 CD0D0B    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
 0A7B C9        	RET
                
                ;******************************************************
                ; PUT DCM CONTROL BLOCK  			      *
                ;******************************************************
                
 0A7C 3E01      PUT$CB:	MVI	A,DC$MB0	;REQUEST BANK 0
 0A7E D343      	OUT	D$PORT
                
 0A80 010700    	LXI	B,7		;NMBR BYTE TO MOVE.
 0A83 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0A86 117003    	LXI	D,DD$CBT	;COMMAND BYTE OFFSET.
 0A89 19        	DAD	D
 0A8A EB        	XCHG			;DE NOW PTS CMND BLK.
 0A8B 21230B    	LXI	H,DCM$CMD	;PC2FLOP CMND BLOCK.
 0A8E CD0D0B    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
 0A91 C9        	RET
                
                ;******************************************************
                ; SET COMMAND     				      *
                ;******************************************************
                
 0A92 32230B    SETCMD	STA	DCM$CMD		;SAVE DCM COMMAND.
 0A95 C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; SET DRIVE NUMBER				      *
                ;******************************************************
                
 0A96 32240B    SETDRV	STA	DCM$DRV		;SAVE DRIVE NUMBER.
 0A99 C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; SET TRACK NUMBER				      *
                ;******************************************************
                
 0A9A 32250B    SETTRK	STA	DCM$TRK		;SAVE TRACK NUMBER.
                
 0A9D 0E1A      	MVI	C,NUMSEC	;26 SECTORS PER TRACK
 0A9F FE01      	CPI	1		;TRACK 1?
 0AA1 C2A60A    	JNZ	NTRK1		;NOT TRACK 1
 0AA4 0E32      	MVI	C,NUMSEC1	;50 SECTORS PER TRACK
                
 0AA6 79        NTRK1	MOV	A,C
 0AA7 329208    	STA	numSecs
 0AAA C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; SET SECTOR NUMBER				      *
                ;******************************************************
                
 0AAB 32260B    SETSEC:	STA	DCM$SEC		;SAVE SECTOR NUMBER.
 0AAE C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; READ SECTOR - BUFFER TO STORE IN HL. DCM.TRK AND    *
                ; DCM.SEC ARE SET UPON ENTRY			      *
                ;******************************************************
                
 0AAF 3E01      RDSEC:	MVI	A,DCM$RDS	;DCM READ SECTOR
 0AB1 CDDA0A    	CALL	DSK$EX		;EXECUTE ON DD
                
 0AB4 E5        	PUSH	H		;SAVE DEST BUFFER
 0AB5 018000    	LXI	B,DD$BFL	;NMBR BYTE TO MOVE.
 0AB8 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0ABB 118003    	LXI	D,DD$BUF	;SECTOR BUFFER OFFSET
 0ABE 19        	DAD	D		;HL NOW PTS SECTOR BUF.
 0ABF D1        	POP	D		;RESTORE DEST BUFFER
 0AC0 CD0D0B    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
                	
 0AC3 C9        	RET			;ERROR RETURN.
                
                ;******************************************************
                ; WRITE SECTOR - BUFFER TO WRITE IN HL. DCM.TRK AND   *
                ; DCM.SEC ARE SET UPON ENTRY			      *
                ;******************************************************
                
 0AC4 E5        WRSEC:	PUSH	H		;SAVE SOURCE BUFFER
 0AC5 018000    	LXI	B,DD$BFL	;NMBR BYTE TO MOVE.
 0AC8 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0ACB 118003    	LXI	D,DD$BUF	;SECTOR BUFFER OFFSET
 0ACE 19        	DAD	D		;HL NOW PTS CMND BLK.
 0ACF EB        	XCHG
 0AD0 E1        	POP	H		;RESTORE SOURCE BUFFER
 0AD1 CD0D0B    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
                	
                ;*******( PERFORM WRITE SECTOR )***********************
                
 0AD4 3E02      	MVI	A,DCM$WRS	;DCM WRITE SECTOR
 0AD6 CDDA0A    	CALL	DSK$EX		;BIOS WRITE SECTOR.
 0AD9 C9        	RET			;ERROR RETURN.
                
                ;******************************************************
                ; DOUBLE D EXECUTION SUBROUTINE			      *
                ;******************************************************
                
                ;*******( COMMAND BLOCK TO DOUBLE D AND EXEC )*********
                
 0ADA E5        DSK$EX	PUSH	H		;SAVE H
 0ADB 32230B    	STA	DCM$CMD		;STORE DCM COMMAND.
 0ADE CD7C0A    	CALL	PUT$CB
                
 0AE1 3E02      	MVI	A,DC$EXC	;LOAD DD INTERRUPT.
 0AE3 D343      	OUT	D$PORT		;ISSUE DD INTERRUPT.
                
                ;*******( WAIT FOR DOUBLE D HALT )*********************
                
 0AE5 3A4200    	LDA	D$MASK		;LOAD HALT BIT MASK.
 0AE8 47        	MOV	B,A		;MASK IN B REGISTER.
 0AE9 11FFFF    	LXI	D,0FFFFH	;LOOP COUNTER
 0AEC DB43      WAIT	IN	D$PORT		;READ DD STATUS.
 0AEE A0        	ANA	B		;TEST HALT* FLAG.
 0AEF CA040B    	JZ	HALTED		;TEST UNTIL HALTED.
 0AF2 1B        	DCX	D
 0AF3 7B        	MOV	A,E
 0AF4 B2        	ORA	D
 0AF5 C2EC0A    	JNZ	WAIT
                
 0AF8 215C07    	LXI	H,mDDTO		;DISPLAY NO DD FOUND
 0AFB CD4D03    	CALL	dispMsg
 0AFE 3E80      	MVI	A,ST$DNR	;SET DRIVE NOT READY
 0B00 B7        	ORA	A		;CLEAR ZERO FLAG
 0B01 C30B0B    	JMP	EX$DONE
                
                ;*******( GET DOUBLE D STATUS )************************
                
 0B04 CD670A    HALTED	CALL	GET$CB
 0B07 3A2A0B    	LDA	DCM$STS
 0B0A A7        	ANA	A		;TEST FOR ERRORS.
 0B0B E1        EX$DONE	POP	H		;RESTORE H
 0B0C C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; BLOCK MOVE SUBROUTINE (Z80 BLOCK MOVE REGISTERS)    *
                ;******************************************************
                
 0B0D 7E        BLK$MV:	MOV	A,M		;GET BYTE.
 0B0E 23        	INX	H		;INC POINTER
 0B0F EB        	XCHG			;GET DESTINATION.
 0B10 77        	MOV	M,A		;PUT BYTE.
 0B11 23        	INX	H		;INC POINTER
 0B12 EB        	XCHG			;GET SOURCE.
 0B13 0B        	DCX	B		;ONE LESS TO DO.
 0B14 78        	MOV	A,B		;GET HI COUNT.
 0B15 B1        	ORA	C		;GET LO COUNT.
 0B16 C20D0B    	JNZ	BLK$MV		;FINISH LOADING.
 0B19 C9        	RET
                
                ;******************************************************
                ; DISPLAY DCM ERROR IN A 			      *
                ;******************************************************
                
 0B1A 218607    DCM$ER	LXI	H,mDNR		;DRIVE NOT READY
 0B1D E680      	ANI	ST$DNR
 0B1F C24D03    	JNZ	dispMsg
                
 0B22 C9        	RET
                
                ;******************************************************
                ; DOUBLE D - DCM COMMAND BLOCK BUFFER		      *
                ;******************************************************
                
 0B23 00        DCM$CMD DB	0		;DCM COMMAND.
 0B24 00        DCM$DRV DB	0		;DRIVE NUMBER.
 0B25 00        DCM$TRK DB	0		;TRACK NUMBER.
 0B26 00        DCM$SEC DB	0		;SECTOR NUMBER.
 0B27 00        DCM$SP0 DB	0		;SPARE BYTE 0.
 0B28 00        DCM$CHR DB	0		;LIST CHARACTER.
 0B29 00        DCM$MOD DB	00000000B	;MODE CONTROLS.
 0B2A 00        DCM$STS DB	0		;COMMAND STATUS.
                
                ;******************************************************
                ; TRACK BUFFER RUNS FROM HERE TO THE END OF MEMORY    *
                ;******************************************************
                
 0B2B =         trkBuf	equ	$
                
 0B2B           	end
