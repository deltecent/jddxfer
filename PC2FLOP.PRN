

                ;******************************************************************************
                ;
                ;  PC2Flop - Transfer disk image from PC to floppy over serial port.
                ;		(for JADE Double D disk controller)
                ;
                ;	This program writes a SSSD soft-sectored 8" floppy with a disk image
                ;	transmitted from a PC. The image is transmitted through a 2SIO at I/O
                ;	address 010h or 12h, or an SIO at address 0 using the XMODEM protocol.
                ;
                ;	The program talks directly to the Jade Double D controller and does not
                ;	require CP/M or an OS to function. The only requirement is that DCM
                ;	must be running on the DD. The JDDUTIL utility can be used for this
                ;	purpose.
                ;
                ;	Since this is a soft sectored controller, the destination disk must
                ;	have been formatted at some point.
                ;
                ;	This program works best if console port and the transfer port
                ;	are not the same device. Otherwise, most error messages won't
                ;	be seen as the file transfer dialog box prevents their display.
                ;
                ;	The program runs standalone at 0x100 or under CP/M. The program
                ;	is exited with a CTRL-C and either warm boots CP/M or just starts
                ;       over when running stand alone.
                ;
                ;	Written by Mike Douglas
                ;	Modified for JADE Double D by Patrick Linstruth
                ;
                ;	Rev	 Date	    Desc
                ;	1.0	 05/23/20   Original
                ;
                ;*****************************************************************************
                
                ; Disk information equates
                
 004D =         NUMTRK	equ	77		;number of tracks
 001A =         NUMSEC	equ	26		;number of sectors per track
 0032 =         NUMSEC1	equ	50		;number of sectors per track
 0018 =         XTRASEC	equ	(NUMSEC1-NUMSEC);extra sectors to read on first pass
 0080 =         SECLEN	equ	128		;sector length (as transmitted)
 0000 =         MINDRV	equ	0		;first drive number
 0003 =         MAXDRV	equ	3		;max drive number 
                
 0D00 =         TRKLEN	equ	(NUMSEC*SECLEN)	;length of track in bytes
 1900 =         TRKLEN1	equ	(NUMSEC1*SECLEN);length of track in bytes
 0C00 =         XTRALEN	equ	(XTRASEC*SECLEN);extra length of track 1
 0005 =         RDTRIES	equ	5		;number of read (verify) attempts
 0004 =         WRTRIES	equ	4		;number of write attempts
                
                ; Monitor, CP/M boot entry points
                
                MONITOR	set	init		;no monitor, just start over
                CPMBOOT	set	0		;CP/M warm boot jump vector
                
                ; XMODEM equates
                
 0080 =         PKTLEN	equ	128		;128 byte xmodem packet length
 0001 =         SOH	equ	001h
 0004 =         EOT	equ	004h
 0006 =         ACK	equ	006h
 0015 =         NAK	equ	015h
 0018 =         CAN	equ	018h
 001A =         EOF	equ	01ah		;ctrl-z character
                
                ; CP/M Equates
                
 0000 =         WBOOT	equ	0		;warm boot jump location
                
                ; Misc equates
                
 000D =         CR	equ	13		;ascii for carriage return
 000A =         LF	equ	10		;ascii for line feed
 007F =         DEL	equ	7fh		;ascii DEL
 0008 =         BS	equ	08h		;ascii backspace
 0003 =         CTRLC	equ	03		;ascii for control-c
 00C3 =         JMPINST	equ	0c3h		;jump instruction opcode
                
 0100           	org	0100h	
                ;-----------------------------------------------------------------------------
                ;  Initialize for transfer
                ;-----------------------------------------------------------------------------
 0100 31D209    init	lxi	sp,ourStk	;initialize stack pointer
 0103 CDFA03    	call	chkCpm		;set flag for CP/M or not
 0106 CD3804    	call	sizeRam		;determine amount of RAM available
 0109 CDD907    	call	s2Init		;initialize the 88-2SIO ports
 010C 3E00      	mvi	a,MINDRV	;a=default drive
 010E 32DD08    	sta	drvNum		;need for pgmExit
                
                ;  Display welcome message, then get the drive number and port number
                ;    to use for the transfer from the operator.
                
 0111 218904    	lxi	h,mWelcom	;display welcome message
 0114 CD3D03    	call	dispMsg
                
                ; getDrv - get drive number or letter from the user.
                
 0117 215305    getDrv	lxi	h,mDrive	;display drive number prompt
 011A CD3D03    	call	dispMsg
 011D CD4803    	call	rcvCon		;get byte from the console
 0120 F620      	ori	20h		;upper case letters to lower case
 0122 FE78      	cpi	'x'		;exit requested?
 0124 CAC803    	jz	pgmExit		;yes
                
 0127 217109    	lxi	h,baseDrv	;ascii 1st drive - baseDrv = 0
 012A 96        	sub	m
 012B FE04      	cpi	MAXDRV-MINDRV+1	;validate >=min drive and <= max drive
 012D D21701    	jnc	getDrv		;invalid, prompt again
                
 0130 C600      	adi	MINDRV		;restore offset of 1st drive (if any)
 0132 32DD08    	sta	drvNum		;save the drive number to use
                
                ; Check if DCM is running and drive status
                
 0135 CD030A    	call	INI$DD
 0138 CA4101    	jz	dcmRdy		;DCM found and running
 013B CDD70A    	call	DCM$ER		;display DCM error
 013E C31701    	jmp	getDrv
                
 0141 CD8B08    dcmRdy:	call	dChkWP		;check write protect (aborts to getDrv)
                
                ; getVrfy - Ask to verify sectors
                
 0144 219005    getVrfy	lxi	h,mVerify	;display verify prompt
 0147 CD3D03    	call	dispMsg
 014A CD4803    	call	rcvCon		;get byte from console
 014D F620      	ori	20h
 014F FE6E      	cpi	'n'
 0151 0600      	mvi	b,0		;set b to 0
 0153 CA6101    	jz	getPort		;do not verify
 0156 FE79      	cpi	'y'
 0158 C24401    	jnz	getVrfy		;invalid response - try again
 015B 0601      	mvi	b,1
                
 015D 78        setVrfy	mov	a,b
 015E 327009    	sta	vfyFlag		;a to vfyFlag
                
                ; getPort - get serial port number from the user.
                
 0161 21B305    getPort	lxi	h,mPort		;display transfer port prompt
 0164 CD3D03    	call	dispMsg
 0167 CD4803    	call	rcvCon		;get byte from the console
 016A F620      	ori	20h		;upper to lower case, nums not affected
 016C FE78      	cpi	'x'		;exit requested?
 016E CAC803    	jz	pgmExit		;yes
                
 0171 D631      	sui	'1'		;'1' - '3' to bianry 0-2
 0173 FE03      	cpi	3		;validate ascii 1-3
 0175 D26101    	jnc	getPort		;invalid, prompt again
                
 0178 326909    	sta	xfrPort		;save the port to use
                
                ; Prompt the user to insert the disk to write, initialize, then start
                ;   sending NAK to start the XMODEM reception.
                
 017B 214D06    	lxi	h,mStart	;display start file transfer prompt
 017E CD3D03    	call	dispMsg
                
 0181 AF        	xra	a		;init track we're reading to zero
 0182 32DE08    	sta	trkNum
                
 0185 3C        	inr	a		;init xmodem block number to one
 0186 326A09    	sta	blkNum
                
 0189 21E80A    	lxi	h,trkBuf	;trkBuf is initial starting point for
 018C 226D09    	shld	rcvPtr		;   XMODEM receive
                
 018F 3E15      	mvi	a,NAK		;send starting nak after purging input data
 0191 CD7603    	call	purgSio
                
                ;-----------------------------------------------------------------------------
                ;  mainLp - Receive as many packets as will fit into RAM and then write
                ;      tracks to disk. Repeat until entire disk is written. 
                ;-----------------------------------------------------------------------------
 0194 CDF601    mainLp	call	bufPkts		;buffer as many packets as possible
 0197 EB        	xchg			;de=start of last packet received
 0198 21E80A    	lxi	h,trkBuf	;hl=start of track buffer
 019B 22E108    	shld	trkPtr		;writing will start from here
 019E CD7D04    	call	cmpDeHl		;compare last packet start - trkBuf
 01A1 DAE501    	jc	allDone		;nothing received but an EOT
                
                ; trkLoop - write tracks until all disk tracks have been written or all
                ;    the tracks in the buffer have been written.
                	
 01A4 CD9602    trkLoop	call	wrtTrk		;write a track (hl returns->next track)
                
 01A7 3ADE08    	lda	trkNum		;increment track number (preserve HL)
 01AA 3C        	inr	a
 01AB 32DE08    	sta	trkNum	
 01AE FE4D      	cpi	NUMTRK		;done all tracks?
 01B0 CAE501    	jz	allDone		;yes
                
 01B3 EB        	xchg			;de=next track pointer
 01B4 2A6D09    	lhld	rcvPtr		;hl=start of last packet received
 01B7 CD7804    	call	cmpHlDe		;compare rcvPtr-start of next track
 01BA D2A401    	jnc	trkLoop		;another track is present
                
                ; All the buffered tracks have been written. Move any bytes left over
                ;    from the xmodem receive to the start of trkbuf. Adjust rcvPtr
                ;    to the end of that data which is where reception of the next
                ;    packet will begin.
                
 01BD CD8204    	call	subHlDe		;hl=hl-de = left over byte count - PKTLEN
 01C0 7D        	mov	a,l		;a=left over count - PKTLEN
 01C1 C680      	adi	PKTLEN		;a=left over byte count
 01C3 47        	mov	b,a		;b=left over byte count (bytes to move)
 01C4 21E80A    	lxi	h,trkBuf	;hl->start of trkBuf
 01C7 CAD201    	jz	mvDone		;no bytes to move, we're done
                	
                ; Copy the leftover data to the start of trkBuf. The next XMODEM receive
                ;   sequence will start at the end of this copied data instead of at the
                ;   start of trkBuf.
                
 01CA 1A        moveLp	ldax	d		;move from end of trkBuf to start of trkBuf
 01CB 77        	mov	m,a
 01CC 23        	inx	h		;hl->starting bytes of trackbuf
 01CD 13        	inx	d		;de->unwritten bytes from end of trkBuf		
 01CE 05        	dcr	b
 01CF C2CA01    	jnz	moveLp
                
 01D2 226D09    mvDone	shld	rcvPtr		;save address where to receive next packet
                
 01D5 EB        	xchg			;save rcvPtr in de
                
 01D6 2AE508    	lhld	bufEndS		;now that we've written the buffer containing
 01D9 22E308    	shld	bufEnd		;extra track 1 sectors, set bufEnd for 26 sectors
                
 01DC EB        	xchg			;rcvPtr in hl
                
 01DD 3E06      	mvi	a,ACK		;ACK the last packet or EOT
 01DF CD8003    	call	sndByte
                
 01E2 C39401    	jmp	mainLp		;go receive more packets
                
                ; allDone - The disk is completely written. ACK the final packet (or EOT),
                ;     display the "transfer complete" message and start the program over.
                
 01E5 3E06      allDone	mvi	a,ACK		;ACK the final packet or EOT
 01E7 CD8003    	call	sndByte
                
 01EA CDA108    	call	dRestor
                
 01ED 218806    	lxi	h,mDone		;hl->done message
 01F0 CD3D03    	call	dispMsg
 01F3 C31701    	jmp	getDrv		;start over asking for drive num
                
                ;-----------------------------------------------------------------------------
                ; bufPkts - Receive XMODEM packets until we fill all the track buffer
                ;   space available. Reception starts at the address pointed to by
                ;   rcvPtr. Reception is stopped when the last packet exactly
                ;   fills or "crosses" the end of the last track spot in RAM. rcvPtr is
                ;   updated on exit to point to the start of the last packet received.
                ;   The disk write routines use this pointer to know where data ends and
                ;   then update rcvPtr to start to where to begin receiving new packets.
                ;-----------------------------------------------------------------------------
 01F6 CD2002    bufPkts	call	rcvPkt		;receive a packet
 01F9 EB        	xchg			;de=current xmodem receive pointer
 01FA FE04      	cpi	EOT		;EOT received?
 01FC CA1102    	jz	bufDone		;yes, buffering is done
                
 01FF 2AE308    	lhld	bufEnd		;hl=end of buffering space	
 0202 CD7D04    	call	cmpDeHl		;compare current-end	
 0205 D21102    	jnc	bufDone		;past or at end, buffering is done
                
 0208 3E06      	mvi	a,ACK		;otherwise, ACK the packet
 020A CD8003    	call	sndByte
 020D EB        	xchg			;put xmodem rcv pointer back in HL
 020E C3F601    	jmp	bufPkts		;buffer some more
                
                ; bufDone - no more room for packets. Update rcvPtr to point to the 
                ;   start of the last packet received so the disk write routines know
                ;   where data ends.
                
 0211 EB        bufDone	xchg			;hl=current xmodem receive pointer
 0212 1180FF    	lxi	d,-PKTLEN
 0215 19        	dad	d		;hl=hl-PKTLEN = start of last rcv'd packet
 0216 226D09    	shld	rcvPtr		;save use by write tracks
 0219 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; rcvPkt - receive an xmodem format 128 byte packet. HL points to the 128 byte
                ;    buffer to receive. HL is updated by 128 bytes after each succuessful
                ;    reception of a new 128 byte packet.
                ;-----------------------------------------------------------------------------
 021A E1        nakPkt	pop	h		;get HL back
 021B 3E15      	mvi	a,NAK
 021D CD7603    	call	purgSio		;purge receive for 1s then transmit NAK
                
                ;wait for SOH, CAN, or EOT
                
 0220 E5        rcvPkt	push	h		;save HL for retries
 0221 CDB903    waitSoh	call	chkQuit		;check for user abort
 0224 3E03      	mvi	a,3		;3 second timeout for soh
 0226 CD8703    	call	rcvByte		;receive character with timeout
 0229 CA1A02    	jz	nakPkt		;timeout
                
 022C FE01      	cpi	SOH		;SOH received?
 022E CA4602    	jz	haveSoh
                
 0231 FE18      	cpi	CAN		;CAN received?
 0233 C23F02    	jnz	chkEoh		;restart
                
 0236 216906    	lxi	h,mCancel
 0239 CD3D03    	call	dispMsg
 023C C3C203    	jmp	restart
                
 023F FE04      chkEoh	cpi	EOT		;EOT to say we're done?
 0241 C22102    	jnz	waitSoh		;no, keep looking for SOH
                
 0244 E1        	pop	h		;undo the entry push
 0245 C9        	ret			;return with EOT
                
                ;  Have SOH, receive block number and not block number
                
 0246 3E01      haveSoh	mvi	a,1		;one second timeout once inside a packet
 0248 CD8703    	call	rcvByte		;get the block number
 024B CA1A02    	jz	nakPkt		;timeout, NAK and start over
                
 024E 326B09    	sta	rcvBlk		;save the received block number
 0251 3E01      	mvi	a,1		;one second timeout
 0253 CD8703    	call	rcvByte		;get not block number
 0256 CA1A02    	jz	nakPkt		;timeout, NAK and start over
                
 0259 326C09    	sta	rcvNBlk		;save not block number
                
                ;  Receive the 128 byte block
                
 025C 1E00      	mvi	e,0		;init checksum
 025E 1680      	mvi	d,pktLen	;d is byte counter
 0260 3E01      pktLoop	mvi	a,1		;one second timeout
 0262 CD8703    	call	rcvByte		;get next data byte
 0265 CA1A02    	jz	nakPkt		;timeout
                
 0268 77        	mov	m,a		;store the character
 0269 23        	inx	h		;point to next byte
 026A 83        	add	e		;update the checksum
 026B 5F        	mov	e,a
 026C 15        	dcr	d		;decrement bytes remaining
 026D C26002    	jnz	pktLoop
                
                ;  Verify the checksum
                
 0270 3E01      	mvi	a,1		;one second timeout
 0272 CD8703    	call	rcvByte		;get the checksum
 0275 CA1A02    	jz	nakPkt		;timeout
                
 0278 BB        	cmp	e		;checksum match?
 0279 C21A02    	jnz	nakPkt		;no, packet error
                
                ;  Checksum good. Verify block numbers
                
 027C 3A6C09    	lda	rcvNBlk		;verify rcvBlk = not (rcvNBlk)
 027F 2F        	cma			;A should = block number now
 0280 47        	mov	b,a		;save in b
 0281 3A6B09    	lda	rcvBlk
 0284 B8        	cmp	b		;compare rcvBlk = not(rcvNBlk)?
 0285 C21A02    	jnz	nakPkt		;no, error
                
 0288 3A6A09    	lda	blkNum		;compare rcvBlk = expected blkNum
 028B B8        	cmp	b
 028C C21A02    	jnz	nakPkt		;nak if not the same (also nak's re-send)
                
 028F 3C        	inr	a		;increment expected block number
 0290 326A09    	sta	blkNum
 0293 C1        	pop	b		;get HL off stack, but don't clobber HL
 0294 AF        	xra	a		;return a zero
 0295 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; wrtTrk - write and verify NUMSEC sectors to the current track in trkBuf
                ;   as pointed to by trkPtr. After the track is written, trkPtr is updated
                ;   by the length of a track to point to the next track buffer. This
                ;   saved value is also returned in HL.
                ;-----------------------------------------------------------------------------
 0296 21DE08    wrtTrk	lxi	h,trkNum	;get desired track from trkNum	
 0299 6E        	mov	l,m		;and put into l
 029A CD9A08    	call	dSeek		;seek to the track
                
 029D 3E04      	mvi	a,WRTRIES	;init write retry counter
 029F 326809    	sta	wrRetry
                
 02A2 1E00      noWrap	mvi	e,0		;reset sector
                
                ; rtryWrt - write a track and the retry entry point.
                
 02A4 3ADF08    rtryWrt	lda	numSecs
 02A7 57        	mov	d,a		;d=count of sectors to write
                	
                ; wrtLoop - write a full track starting after the sector in e.
                
 02A8 CDC508    wrtLoop	call	dNxtSec		;get next sector number and offset
 02AB 2AE108    	lhld	trkPtr		;hl->start of current track buffer
 02AE 09        	dad	b		;bc has offset of sector within track
 02AF CD6F08    	call	dWrite		;write the sector
 02B2 C21603    	jnz	wrtErr		;write failed
                
 02B5 15        	dcr	d		;decrement sector count
 02B6 C2A802    	jnz	wrtLoop		;loop until all sectors written
                
 02B9 3A7009    	lda	vfyFlag		;verify track?
 02BC B7        	ora	a
 02BD CADA02    	jz	noVfy
                
                ; Verify the track just written
                
 02C0 3ADF08    	lda	numSecs
 02C3 57        	mov	d,a		;d=count of sectors to verify
 02C4 1E00      	mvi	e,0		;reset sector
                
 02C6 CDB903    vfyLoop	call	chkQuit		;check for ctrl-c
 02C9 CDC508    	call	dNxtSec		;get next sector number and offset
 02CC 2AE108    	lhld	trkPtr		;hl->start of current track buffer
 02CF 09        	dad	b		;bc has offset of sector within track
 02D0 CD6908    	call	dVerify		;verify the sector
 02D3 C2F002    	jnz	vfyRtry		;error, go to retry logic
                
 02D6 15        vfyNext	dcr	d		;decrement sector count
 02D7 C2C602    	jnz	vfyLoop		;loop until all sectors verified
                
                ; Track verified, increment trkPtr to memory location for next track
                ;    and exit.
                
 02DA 2AE108    noVfy	lhld	trkPtr		;hl=current track pointer
 02DD 110019    	lxi	d,TRKLEN1	;de=bytes in a track 1
 02E0 3ADE08    	lda	trkNum		;track 1?
 02E3 FE01      	cpi	1
 02E5 CAEB02    	jz	trk1
                
 02E8 11000D    	lxi	d,TRKLEN	;de=bytes in a track 0,2-76
 02EB 19        trk1	dad	d		;hl=start of next track in trkBuf
 02EC 22E108    	shld	trkPtr
 02EF C9        	ret
                
                ; vfyRtry - verify failed, retry reads followed by a re-write
                ;   of the track in needed.
                
 02F0 3E05      vfyRtry	mvi	a,RDTRIES	;init retry counter
 02F2 326709    	sta	rdRetry
                
 02F5 CDB903    retryLp	call	chkQuit		;check for ctrl-c
 02F8 CDD308    	call	dWtSec		;wait for sector specified in e
 02FB 2AE108    	lhld	trkPtr		;hl->start of current track buffer
 02FE 09        	dad	b		;bc has offset of sector within track
 02FF CD6908    	call	dVerify		;verify the sector
 0302 CAD602    	jz	vfyNext		;success, go verify next sector
                
                ; Re-verify failed. Decrement retry count and try again if not zero. Once
                ;   retry counter expires, do another write.
                
 0305 216709    	lxi	h,rdRetry	;decrement the read retry counter
 0308 35        	dcr	m
 0309 C2F502    	jnz	retryLp		;try again
                
                ; read re-tries expired, decrement the write retry count and re-write
                ;    if not expired
                
 030C 216809    	lxi	h,wrRetry	;decrement the write retry counter
 030F 35        	dcr	m
 0310 C2A402    	jnz	rtryWrt		;retry starting with the write
                
 0313 C32103    	jmp	vfyErr		;display the error and restart
                
                ;-----------------------------------------------------------------------------
                ; Disk write verify failure. Display the track and sector with the error. 
                ;    Restart the program.
                ;-----------------------------------------------------------------------------
 0316 E610      wrtErr	ani	ST$RNF		;sector not found error?
 0318 CA2103    	jz	vfyErr		;no
                
 031B 21CA06    	lxi	h,mNoSec	;'sector not found, format needed?'
 031E CD3D03    	call	dispMsg
                
 0321 210E07    vfyErr	lxi	h,errTrk	;hl->where to put ascii decimal
 0324 3ADE08    	lda	trkNum		;a=track with error on it
 0327 CDA103    	call	bin2dec		;track to ascii
                
 032A 211907    	lxi	h,errSec	;hl->where to put ascii sector
 032D 7B        	mov	a,e		;a=sector where error occured
 032E CDA103    	call	bin2dec
                
 0331 21F406    	lxi	h,mDskErr	;display the error message
 0334 CD3D03    	call	dispMsg
 0337 31D209    	lxi	sp,ourStk	;initialize stack pointer
 033A C31701    	jmp	getDrv		;start over asking for drive num
                
                ;-----------------------------------------------------------------------------
                ; dispMsg - display the null-terminated message passed in hl on the
                ;    console device. Clobbers b, hl
                ;-----------------------------------------------------------------------------
 033D 7E        dispMsg	mov	a,m		;get the next message byte
 033E B7        	ora	a		;null terminates
 033F C8        	rz
                
 0340 47        	mov	b,a		;conOut wants character in b
 0341 CDF707    	call	conOut
 0344 23        	inx	h		;move to next byte
 0345 C33D03    	jmp	dispMsg
                
                ;-----------------------------------------------------------------------------
                ; rcvCon - Receive a character from the console device, echo it, then
                ;   wait for a CR. Exits program if Ctrl-c typed. Returns with invalid
                ;   character (null) if BS or DEL pressed after 1st character
                ;   Returns character in a, clobbers b.
                ;-----------------------------------------------------------------------------
 0348 CDEF07    rcvCon	call	conIn		;check for input
 034B CA4803    	jz	rcvCon		;nothing
                
 034E E67F      	ani	7fh
 0350 FE03      	cpi	CTRLC		;abort requested?
 0352 CAC803    	jz	pgmExit		;yes
                
 0355 FE0D      	cpi	CR		;return pressed?
 0357 C8        	rz			;yes, don't echo it
                
 0358 47        	mov	b,a		;conOut needs character in b
 0359 CDF707    	call	conOut		;echo it
                
                ; Wait for CR, then return 1st character typed
                
 035C CDEF07    rcvCr	call	conIn		;check for input
 035F CA5C03    	jz	rcvCr		;nothing
                
 0362 E67F      	ani	7fh
 0364 FE03      	cpi	CTRLC		;abort requested?
 0366 CAC803    	jz	pgmExit		;yes
                
 0369 FE7F      	cpi	DEL		;delete
 036B C8        	rz			;yes, return DEL character
                
 036C FE08      	cpi	BS		;backspace?
 036E C8        	rz			;yes, return BS character
                
 036F FE0D      	cpi	CR		;return pressed?
 0371 C25C03    	jnz	rcvCr		;no, keep waiting
                
 0374 78        	mov	a,b		;return 1st character typed
 0375 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; purgSio - wait for 1 second of idle time on receive line, then transmit the
                ;	character passed in A (usually ACK or NAK). Clobbers b
                ;-----------------------------------------------------------------------------
 0376 F5        purgSio	push	a
                
 0377 3E01      purge	mvi	a,1		;1 second timeout
 0379 CD8703    	call	rcvByte		;wait for 1 second without activity
 037C C27703    	jnz	purge
                
 037F F1        	pop	a		;get back the character to send
                				;fall through to sndByte
                ;-----------------------------------------------------------------------------
                ; sndByte - send the byte in a through the specified transfer port. 
                ;     Clobbers b. (assuming serOut clobbers only a).
                ;-----------------------------------------------------------------------------
 0380 47        sndByte	mov	b,a		;b=byte to transmit
 0381 3A6909    	lda	xfrPort		;a=port to use for transfer
 0384 C32208    	jmp	serOut		;send the character
                
                ;-----------------------------------------------------------------------------
                ; rcvByte - Receive a byte from the specified transfer port. A wait timeout
                ;     in seconds is specified in a. If a timeout occurs, zero is returned in
                ;     a and the zero flag is true. Otherwise, the character is returned in a 
                ;     (could be zero) and the zero flag is false. ONESEC must be set based
                ;     on processor speed and the number of cycles in the serIn call + 59.
                ;     Clobbers a, b and c.
                ;-----------------------------------------------------------------------------
 0387 D5        rcvByte	push	d		;save d, e
 0388 57        	mov	d,a		;save timeout in d
                
 0389 011F4B    initSec	lxi	b,ONESEC	;one second timeout 104 cycles per loop
                
 038C 3A6909    rcvWait	lda	xfrPort		;(13) a=port to use for transfer
 038F CD0208    	call	serIn		;(17+45) look for a byte
 0392 C29F03    	jnz	haveChr		;(10) byte received
                
 0395 0B        	dcx	b		;(5) otherwise, decrement timer
 0396 78        	mov	a,b		;(5) one second expire?
 0397 B1        	ora	c		;(4)
 0398 C28C03    	jnz	rcvWait		;(10) no, keep waiting
                
                ; one second timeout has occured. Decrement the seconds counter.
                
 039B 15        	dcr	d		;decrement seconds counter
 039C C28903    	jnz	initSec		;initialize for another 1 second count
 039F D1        haveChr	pop	d		;restore d, e
 03A0 C9        	ret
                
                ;--------------------------------------------------------------
                ; bin2dec - Binary byte in A to 2 ASCII digits at (HL)
                ;   HL is preserved
                ;--------------------------------------------------------------
 03A1 3620      bin2dec	mvi	m,' '		;assume zero supression
 03A3 D60A      	sui	10		;value less than 10?
 03A5 DAB303    	jc	do1s		;yes, leading blank
 03A8 3631      	mvi	m,'1'		;have one ten already
                
 03AA D60A      loop10	sui	10		;count 10s
 03AC DAB303    	jc	do1s		;done with 10s, do 1s
 03AF 34        	inr	m
 03B0 C3AA03    	jmp	loop10
                
 03B3 C63A      do1s	adi	'0'+10		;form ASCII 1s digit
 03B5 23        	inx	h		;move to 1s position
 03B6 77        	mov	m,a
 03B7 2B        	dcx	h		;restore hl
 03B8 C9        	ret
                
                ;--------------------------------------------------------------
                ; chkQuit - check for the user to request abort (ctrl-c). If
                ;    a character is present on the console port, read it and
                ;    see if ctrl-c. Clobbers A
                ;--------------------------------------------------------------
 03B9 CDEF07    chkQuit	call	conIn		;check for console input
 03BC C8        	rz
                
 03BD E67F      	ani	7fh
 03BF FE03      	cpi	CTRLC		;abort requested?
 03C1 C0        	rnz			;no
                
                ; Ctrl-C typed while program is running. Return to drive prompt.
                
 03C2 31D209    restart	lxi	sp,ourStk	;initialize stack pointer
 03C5 C31701    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; pgmExit - Exit to CP/M or to the monitor ROM based on the
                ;    CP/M flag
                ;--------------------------------------------------------------
 03C8 3A6F09    pgmExit	lda	cpmFlag		;running under CP/M?
 03CB B7        	ora	a
 03CC C2D803    	jnz	cpmExit		;yes
                
                ; Exit to ROM monitor
                
 03CF 215307    	lxi	h,mExit		;display "exiting" message
 03D2 CD3D03    	call	dispMsg
 03D5 C30001    	jmp	MONITOR		;jump to ROM monitor entry point
                
                ; CP/M exit. If boot drive was used, prompt user to insert CP/M disk
                
 03D8 3ADD08    cpmExit	lda	drvNum		;boot drive used?
 03DB D600      	sui	MINDRV
 03DD C2E903    	jnz	noDisk		;not 1, disk prompt not needed
                
 03E0 216307    	lxi	h,mCpm		;display "insert cp/m disk"	
 03E3 CD3D03    	call	dispMsg
 03E6 CD4803    	call	rcvCon		;wait for a character
                
 03E9 3E00      noDisk	mvi	a,MINDRV	;re-select drive A for CP/M 1.4
 03EB 32DD08    	sta	drvNum
 03EE CDBE08    	call	dSelDrv
                
 03F1 215307    	lxi	h,mExit		;display "exiting" message
 03F4 CD3D03    	call	dispMsg
 03F7 C30000    	jmp	CPMBOOT		;reboot CP/M
                
                ;--------------------------------------------------------------
                ; chkCpm - check if running under CP/M. CP/M flag is set true
                ;   (non-zero) if yes, cleared otherwise.
                ;--------------------------------------------------------------
                ; First, initialize entries for stand-alone
                
 03FA AF        chkCpm	xra	a
 03FB 326F09    	sta	cpmFlag		;clear CP/M flag
 03FE 3E30      	mvi	a,MINDRV+'0'	;ascii for minimum drive number
 0400 327C05    	sta	mDrvMin		;store in the drive prompt message
 0403 327109    	sta	baseDrv		;ascii 1st drive - baseDrv = 0
 0406 3E33      	mvi	a,MAXDRV+'0'	;ascii for max drive number
 0408 327E05    	sta	mDrvMax
                
                ; Determine if we're under CP/M or standalone. CP/M is assumed if
                ;   a jump instruction is present at the CP/M warm start location (0)
                ;   and five more jumps (e.g., a jump table) is present at the
                ;   jump-to destination.
                		
 040B 3A0000    	lda	WBOOT		;see if jump instruction present for CP/M
 040E FEC3      	cpi	JMPINST
 0410 C0        	rnz			;no, not CP/M
                
                ; A jump instruction is present at the CP/M warm boot location (0),
                ;   now see if that jump points to five more jumps. If so, assume CP/M
                
 0411 210100    	lxi	h,WBOOT+1	;point to lsb of jump address
 0414 5E        	mov	e,m		;e=low byte of jump
 0415 23        	inx	h
 0416 56        	mov	d,m		;de=destination of jump
 0417 0605      	mvi	b,5		;look for 5 more jumps (a jump table)
                
 0419 1A        jmpTest	ldax	d		;a=opcode at jump destination
 041A D6C3      	sui	JMPINST		;another jump present?
 041C C0        	rnz			;no, not CP/M
                
 041D 13        	inx	d		;move to next jump
 041E 13        	inx	d
 041F 13        	inx	d
 0420 05        	dcr	b
 0421 C21904    	jnz	jmpTest
                
 0424 3D        	dcr	a		;a=0ffh
 0425 326F09    	sta	cpmFlag		;CP/M flag to non-zero = true
                
                ; We're running under CP/M. Change drive prompt message to show drive
                ;    letters instead of drive numbers and change baseDrv to convert
                ;    an 'A' to the base drive number (MINDRV).
                
 0428 3E41      	mvi	a,'A'		;'A' in drive message instead of number
 042A 327C05    	sta	mDrvMin
 042D C603      	adi	MAXDRV-MINDRV	;max drive letter
 042F 327E05    	sta	mDrvMax
 0432 3E61      	mvi	a,'a'		;ascii 1st drive - baseDrv = 0
 0434 327109    	sta	baseDrv
 0437 C9        	ret
                
                ;------------------------------------------------------------------
                ; sizeRam - determine how much RAM we have for buffering tracks.
                ;   Sets the bufEnd variable which points to end address of 
                ;   the last possible track buffer + 1
                ;------------------------------------------------------------------
                ; If running under CP/M, use the BIOS pointer to determine the top
                ;    of available RAM. Otherwise, size RAM manually.
                
 0438 2A0100    sizeRam	lhld	WBOOT+1		;get address of BIOS jump table+3
 043B 2B        	dcx	h		
 043C 2B        	dcx	h
 043D 2B        	dcx	h		;hl->top of usable ram+1
 043E 3A6F09    	lda	cpmFlag		;running under CP/M?
 0441 B7        	ora	a
 0442 C25304    	jnz	ramEnd		;yes, we have the end of RAM
                
                ;  Not under CP/M. Find the end of RAM manually.
                
 0445 21000B    	lxi	h,(trkBuf+0ffh) AND 0ff00h   ;next 256 byte boundary
                
 0448 7E        ramLoop	mov	a,m		;a=current RAM content
 0449 34        	inr	m		;change RAM
 044A BE        	cmp	m		;did RAM change?
 044B 77        	mov	m,a		;restore RAM
 044C CA5304    	jz	ramEnd		;end of RAM found
                
 044F 24        	inr	h		;next page
 0450 C24804    	jnz	ramLoop
                
                ; ramEnd - end of RAM found. Subtrack 256 bytes from this to make room
                ;   for xmodem packet overflow at the end. Determine the end address + 1
                ;   of the last track buffer that will fit in RAM. Store in bufEnd
                
 0453 EB        ramEnd	xchg			;de=end of RAM + 1
 0454 3EF2      	mvi	a,-((TRKLEN SHR 8) + 1) AND 0ffh
 0456 BA        	cmp	d		;force de < (10000h - TRKLEN)
 0457 D25B04    	jnc	topOk
                
 045A 57        	mov	d,a		;limit max address
                
 045B 15        topOk	dcr	d		;subtract 256 bytes from end of RAM
 045C 21E80A    	lxi	h,trkBuf	;hl=start of track buffer
 045F 01000D    	lxi	b,TRKLEN	;bc=length of track in bytes
                
                ; Loop increasing hl by TRKLEN until hl > end of RAM.
                
 0462 09        bfEndLp	dad	b		;hl=hl+track length
 0463 CD7804    	call	cmpHlDe		;compare hl-de
 0466 DA6204    	jc	bfEndLp		;still more room, keep going
                
                ; Subtrack two track lengths from hl, this will be the end address + 1 of
                ;   the the last track buffer that will fit in RAM
                
 0469 0100E6    	lxi	b,-TRKLEN*2	;subtract two track lengths
 046C 09        	dad	b		;hl = end address of last track + 1
 046D 22E508    	shld	bufEndS		;save non-track 1 bufEnd
 0470 01000C    	lxi	b,XTRALEN
 0473 09        	dad	b		;hl += extra length for track 1
 0474 22E308    	shld	bufEnd		;save as bufEnd
 0477 C9        	ret
                
                ;--------------------------------------------------------------------
                ; cmHlDe - compare HL-DE. Carry set if HL<DE, carry clear if HL>=DE
                ;--------------------------------------------------------------------
 0478 7D        cmpHlDe	mov	a,l		;compare HL-DE, do lsbs first
 0479 93        	sub	e
 047A 7C        	mov	a,h		;do msbs
 047B 9A        	sbb	d
 047C C9        	ret			;carry set HL<DE, clear HL>=DE
                
                ;--------------------------------------------------------------------
                ; cmDeHl - compare DE-HL. Carry set if DE<HL, carry clear if DE>=HL
                ;--------------------------------------------------------------------
 047D 7B        cmpDeHl	mov	a,e		;compare DE-HL, do lsbs first
 047E 95        	sub	l
 047F 7A        	mov	a,d		;do msbs
 0480 9C        	sbb	h
 0481 C9        	ret			;carry set DE<HL, clear DE>=HL
                
                ;--------------------------------------------------------------------
                ; subHlDe - HL=HL-DE
                ;--------------------------------------------------------------------
 0482 7D        subHlDe	mov	a,l		;subtract HL-DE, do lsbs first
 0483 93        	sub	e
 0484 6F        	mov	l,a		;lsb result in l
 0485 7C        	mov	a,h		;do msbs
 0486 9A        	sbb	d
 0487 67        	mov	h,a		;msb result in h	
 0488 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ;   Data Area
                ;-----------------------------------------------------------------------------
 0489 0D0A0A    mWelcom	db	cr,lf,lf
 048C 3D3D3D3D3D	db 	'===== PC to Floppy Disk Image Transfer =====',cr,lf
 04BA 2020202020	db	'          (JADE Double D, ver 1.0)',cr,lf,lf
 04DF 5772697465	db	'Writes a SSSD 8" floppy with a disk image received via an'
 0518 0D0A      	db	cr,lf
 051A 38382D3253	db	'88-2SIO or 88-SIO serial port using the XMODEM protocol.',0
                
 0553 0D0A0A496EmDrive	db	cr,lf,lf,'Insert and specify destination drive ('
 057C 782D      mDrvMin	db	'x-'
 057E 7829206F72mDrvMax	db	'x) or X to exit: ',0
                
 0590 0D0A566572mVerify	db	cr,lf,'Verify sectors written to disk? ', 0
                
 05B3 0D0A0A    mPort	db	cr,lf,lf
 05B6 5370656369	db	'Specify the port to use for file transfer',cr,lf
 05E1 2020312920	db	'  1) 88-2SIO port A (which is also the console)',cr,lf
 0612 2020322920	db	'  2) 88-2SIO port B',cr,lf
 0627 2020332920	db	'  3) 88-SIO',cr,lf
 0634 456E746572	db	'Enter 1-3 or X to exit: ',0
                
 064D 0D0A0A    mStart	db	cr,lf,lf
 0650 5374617274	db	'Start XMODEM send now...',0
                
 0669 0D0A0A5265mCancel	db	cr,lf,lf,'Received CAN from sender.',cr,lf,0
                
 0688 0D0A0A4372mDone	db	cr,lf,lf,'Creation of new disk successful!',cr,lf,0
                
 06AE 0D0A0A5365mNoTrk0	db	cr,lf,lf,'Seek to track 0 failed',cr,lf,0
                
 06CA 0D0A0A5365mNoSec	db	cr,lf,lf,'Sector not found - disk not formatted?',0
                
 06F4 0D0A0A5772mDskErr	db	cr,lf,lf,'Write failure on track '
 070E 78782C2073errTrk	db	'xx, sector '
 0719 78782E2044errSec	db	'xx. Disk creation aborted.',cr,lf,0
                
 0736 0D0A0A4469mWrtPrt	db	cr,lf,lf,'Disk is write protected',cr,lf,0
                
 0753 0D0A0A4578mExit	db	cr,lf,lf,'Exiting...',cr,lf,0
                
 0763 0D0A0A    mCpm	db	cr,lf,lf
 0766 496E736572	db	'Insert CP/M disk into drive A, then press Return...',0
                
 079A 0D0A0A4443mDDTO	db	cr,lf,lf,'DCM command timeout. Is DCM running?',cr,lf,0
                
 07C4 0D0A0A4472mDNR	db	cr,lf,lf,'Drive Not Ready',cr,lf,0
                
                ;****************************************************************************
                ;
                ;  Hardware specific console and serial I/O routines. 
                ;     The following four routines must be written to provide a common
                ;     interface to the hardware on which this program is running. The
                ;     port number specified for serIn and serOut matches the port number
                ;     input from the operator via the port menu.
                ;
                ;****************************************************************************
                
                ; 88-2SIO Serial Board Equates
                
 0010 =         s2aCtl	equ	010h		;1st port on 88-2SIO board - control register
 0011 =         s2aDat	equ	011h		;1st port on 88-2SIO board - data register
 0012 =         s2bCtl	equ	012h		;2nd port on 88-2SIO board - control register
 0013 =         s2bDat	equ	013h		;2nd port on 88-2SIO board - data register
 0001 =         s2Rdrf	equ	001h		;read data register full flag
 0002 =         s2Tdre	equ	002h		;transmit data register empty flag
 0003 =         s2Rst	equ	003h		;reset command
 0015 =         s28n1	equ	015h		;8N1 selection
 0011 =         s28n2	equ	011h		;8N2 selection
                
                ; 88-SIO Serial board Equates
                
 0000 =         sioCtl	equ	00h		;control port
 0001 =         sioDat	equ	01h		;data port
 0001 =         sioRdrf	equ	00000001b	;-RX Data register full
 0080 =         sioTdre	equ	10000000b	;-TX Data register empty
                
                ; The rcvByte subroutine above times a one second timeout with a code
                ;    loop that calls the hardware specific serIn routine below. ONESEC
                ;    must be set based on processor speed and the number of cycles in 
                ;    the serIn call + 59 cycles for the rcvByte code. 
                
 4B1F =         ONESEC	equ	19231		;rcvByte loop count for 1 second
                
                ;----------------------------------------------------------------------------
                ; s2Init - reset and initialize 88-2SIO ports for 8N1
                ;----------------------------------------------------------------------------
 07D9 3E03      s2Init	mvi	a,s2Rst		;reset and init 2nd 88-2SIO port
 07DB D312      	out	s2bCtl
 07DD 3E15      	mvi	a,s28n1		;transfer port as 8N1
 07DF D312      	out	s2bCtl
                
                ; if not running under CP/M, reset and init 1st 88-2SIO port
                
 07E1 3A6F09    	lda	cpmFlag		;running under CP/M?
 07E4 B7        	ora	a
 07E5 C0        	rnz			;yes, 2SIO already initialized
                
 07E6 3E03      	mvi	a,s2Rst		;reset and init 1st 88-2SIO port
 07E8 D310      	out	s2aCtl
 07EA 3E11      	mvi	a,s28n2		;configure console for 8N2 in case Teletype
 07EC D310      	out	s2aCtl
 07EE C9        	ret	
                
                ;----------------------------------------------------------------------------
                ; conIn - input character from console
                ;    inputs:
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ;    clobbers none
                ;----------------------------------------------------------------------------
 07EF DB10      conIn	in	s2aCtl		;see if a new character is present
 07F1 E601      	ani	s2Rdrf
 07F3 C8        	rz			;no character, return zero status
                
 07F4 DB11      	in	s2aDat		;return character and non-zero status
 07F6 C9        	ret	
                
                ;----------------------------------------------------------------------------
                ; conOut - output character to console
                ;    inputs: b = character to send
                ;    clobbers none
                ;----------------------------------------------------------------------------
 07F7 DB10      conOut	in	s2aCtl		;wait for OK to transmit
 07F9 E602      	ani	s2Tdre
 07FB CAF707    	jz	conOut
 07FE 78        	mov	a,b		;a=character to transmit
 07FF D311      	out	s2aDat		;send it
 0801 C9        	ret
                
                ;----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serIn - input character from port specified in a
                ;       0 = 88-2SIO port A
                ;       1 = 88-2SIO port B
                ;       2 = 88-SIO
                ;    inputs: a = port to read from
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ;    clobbers none
                ; 88-2SIO Port A: 53 cycles including return when no character present
                ; 88-2SIO Port B: 43 cycles including return when no character present
                ; 88-SIO: 57 cycles including return when no character present
                ;-----------------------------------------------------------------------------
 0802 3D        serIn	dcr	a		;(5)3-way test
 0803 CA1108    	jz	s2InB		;(10)a was 1: 88-2SIO port B
 0806 F21908    	jp	sioIn		;(10)a was 2: 88-SIO
                				;    a was 0: 88-2SIO port A
                ; Input from 88-2SIO port A
                
 0809 DB10      s2InA	in	s2aCtl		;(10+1)see if a new character is present
 080B E601      	ani	s2Rdrf		;(7)
 080D C8        	rz			;(10)no character, return zero status
 080E DB11      	in	s2aDat		;return character and non-zero status
 0810 C9        	ret	
                	
                ; Input from 88-2SIO port B
                
 0811 DB12      s2InB	in	s2bCtl		;(10+1)see if a new character is present
 0813 E601      	ani	s2Rdrf		;(7)
 0815 C8        	rz			;(10)no character, return zero status
                
 0816 DB13      	in	s2bDat		;return character and non-zero status
 0818 C9        	ret	
                
                ; Input from 88-SIO
                
 0819 DB00      sioIn	in	sioCtl		;(10+1)see if a new character is present
 081B 2F        	cma			;(4)invert Rx Data Ready flag
 081C E601      	ani	sioRdrf		;(7)
 081E C8        	rz			;(10)no character, return zero status
                
 081F DB01      	in	sioDat		;return character and non-zero status
 0821 C9        	ret	
                
                ;-----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serOut - output character to port specified in a
                ;       0 = 88-2SIO port A
                ;       1 = 88-2SIO port B
                ;       2 = 88-SIO
                ;    inputs: a = port to transmit through
                ;	     b = character to send
                ;    clobbers a
                ;-----------------------------------------------------------------------------
 0822 3D        serOut	dcr	a		;3-way test
 0823 CA3408    	jz	s2OutB		;a was 1: 88-2SIO port B
 0826 F23F08    	jp	sioOut		;a was 2: 88-SIO
                				;a was 0: 88-2SIO port A
                
                ; Send character through 88-2SIO port A
                
 0829 DB10      S2OutA	in	s2aCtl		;wait for OK to transmit
 082B E602      	ani	s2Tdre
 082D CA2908    	jz	S2OutA
                
 0830 78        	mov	a,b		;a=character to transmit
 0831 D311      	out	s2aDat		;send it
 0833 C9        	ret
                
                ; Send character through 88-2SIO port B
                
 0834 DB12      s2OutB	in	s2bCtl		;wait for OK to transmit
 0836 E602      	ani	s2Tdre
 0838 CA3408    	jz	s2OutB
                
 083B 78        	mov	a,b		;a=character to transmit
 083C D313      	out	s2bDat		;send it
 083E C9        	ret
                
                ; Send character through 88-SIO
                
 083F DB00      sioOut	in	sioCtl		;wait for OK to transmit
 0841 E680      	ani	sioTdre
 0843 C23F08    	jnz	sioOut		;active-low flag
                
 0846 78        	mov	a,b		;a=character to transmit
 0847 D301      	out	sioDat		;send it
 0849 C9        	ret
                
                ;--------------------------------------------------------------
                ; dRead - Read sector on current track.
                ; On Entry:
                ;    Drive is selected, on proper track, head loaded
                ;    hl->sector buffer
                ;    e = sector number to read
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;    clobbers h,l
                ;--------------------------------------------------------------
 084A D5        dRead:	push	d		;save d
 084B 7B        	mov	a,e		;set sector
 084C CD930A    	call	SETSEC
 084F 3E01      	mvi	a,DCM$RDS	;dcm read sector
 0851 CD970A    	call	DSK$EX		;execute on dd
 0854 C26608    	jnz	dRdone		;exit if error
                
 0857 E5        	push	h		;save dest buffer
 0858 018000    	lxi	b,DD$BFL	;number of bytes to move
 085B 2A4000    	lhld	D$ADDR		;dd memory address
 085E 118003    	lxi	d,DD$BUF	;sector buffer offset
 0861 19        	dad	d		;hl now pts sector buf
 0862 D1        	pop	d		;restore dest buffer
 0863 CDCA0A    	call	BLK$MV		;perform block move
                
 0866 D1        dRdone	pop	d		;restore d
 0867 AF        	xra	a		;clear error
 0868 C9        	ret			;error return
                
                ;--------------------------------------------------------------
                ; dVerify - Verify sector on current track. The track is
                ;    read to verify CRC, but not compared
                ; On Entry:
                ;    Drive is selected, on proper track, head loaded
                ;    e = sector number to verify
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;    clobbers none
                ;--------------------------------------------------------------
 0869 21E708    dVerify	lxi	h,secBuf	;hl=sector buffer, e=sector
 086C C34A08    	jmp	dRead		;read sector
                
                
                ;--------------------------------------------------------------
                ; dWrite - Write a sector on current track
                ; On Entry:
                ;    Drive is selected, on proper track, head loaded
                ;    hl->buffer address
                ;    e = sector number to write
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;   clobbers h,l
                ;--------------------------------------------------------------
 086F D5        dWrite:	push	d		;save d
 0870 7B        	mov	a,e
 0871 CD930A    	call	SETSEC
 0874 E5        	push	h		;save source buffer
 0875 018000    	lxi	b,DD$BFL	;number of bytes to move
 0878 2A4000    	lhld	D$ADDR		;DD memory address
 087B 118003    	lxi	d,DD$BUF	;sector buffer offset
 087E 19        	dad	d		;hl now pts cmnd blk
 087F EB        	xchg
 0880 E1        	pop	h		;restore source buffer
 0881 CDCA0A    	call	BLK$MV		;perform block move
                	
                ;*******( PERFORM WRITE SECTOR )***********************
                
 0884 3E02      	mvi	a,DCM$WRS	;DCM write sector
 0886 CD970A    	call	DSK$EX		;execute
 0889 D1        	pop	d		;restore d
 088A C9        	ret			;return A if error
                	
                ;--------------------------------------------------------------
                ; dChkWP - check if disk is write protected. 
                ; On Entry:
                ;    disk already selected
                ; On Exit:
                ;    returns if disk is not protected. Otherwise, an error
                ;    message is displayed and the program started over.
                ; Clobbers none
                ;--------------------------------------------------------------
 088B CD4F0A    dChkWP	call	GET$CB		;copy control block from DD
 088E 3AE70A    	lda	DCM$STS		;get status byte
 0891 E640      	ani	ST$WRP		;get write protect bit alone
 0893 C8        	rz			;return if not protected
                
                ; Disk write protected. Display error and restart program.
                
 0894 213607    	lxi	h,mWrtPrt	;otherwise, display error message
 0897 C3B508    	jmp	errMsg		;display error and restart
                
                ;--------------------------------------------------------------
                ; dSeek - Seek track specified in L. Selects drive and loads
                ;    head. If the head was not already loaded, then the E bit
                ;    (wait for head settle one-shot) is set in fWaitHd for
                ;    OR'ing into the subsequent read/write command.
                ; On Entry:
                ;    l = desired track
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ; Clobbers none
                ;--------------------------------------------------------------
 089A F5        dSeek	push	a
 089B 7D        	mov	a,l		;set track number
 089C CD820A    	call	SETTRK
 089F F1        	pop	a
 08A0 C9        	ret			;Jade DD will seek on write
                
                
                ;--------------------------------------------------------------
                ; dRestor - Selects drive, loads heads and restores to track 0.
                ;    If restore fails, message display and program restarted
                ;    at getDrv.
                ; On Entry:
                ;    drvNum = drive to be selected and restored to track zero
                ; On Exit:
                ;    drive selected and on track zero
                ; Clobbers a
                ;--------------------------------------------------------------
 08A1 CDBE08    dRestor	call	dSelDrv		;make sure drive is selected
                
 08A4 AF        	xra	a
 08A5 32E20A    	sta	DCM$TRK
 08A8 3C        	inr	a
 08A9 32E30A    	sta	DCM$SEC
 08AC 3E00      	mvi	a,DCM$LOG	;logon command seeks to track 0
 08AE CD970A    	call	DSK$EX		;Z clear and error in A
 08B1 C8        	rz			;success
                
                ; restore failed
                
 08B2 21AE06    	lxi	h,mNoTrk0
                
 08B5 CD3D03    errMsg	call	dispMsg
 08B8 31D209    	lxi	sp,ourStk	;initialize stack pointer
 08BB C31701    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; dSelDrv - Select and wait for drive specified in drvNum 
                ;    to be ready.
                ; On Entry:
                ;    drvNum = drive to be selected
                ; On Exit:
                ;    drive selected and ready, 1771 not busy
                ; Clobbers a
                ;--------------------------------------------------------------
 08BE 3ADD08    dSelDrv	lda	drvNum		;a=desired drive
 08C1 CD7E0A    	call	SETDRV
 08C4 C9        	ret
                
                ;--------------------------------------------------------------
                ; dNxtSec - wait for next (any) sector. For the 1771, this
                ;    routine simply increments and wraps the sector number
                ;    passed in e, then falls into dWtSec to return bc with
                ;    the offset of the sector within the track buffer.
                ; On Entry:
                ;    Drive is selected, motor is running
                ;    e = most recent sector number
                ; On Exit:
                ;    e = next sector sector number
                ;    bc = byte offset of this sector in a track
                ;--------------------------------------------------------------
 08C5 1C        dNxtSec	inr	e		;move to next sector
 08C6 1C        	inr	e		;skew of 2
                
 08C7 3ADF08    	lda	numSecs
 08CA 47        	mov	b,a
 08CB 04        	inr	b		;numSecs + 1
 08CC 7B        	mov	a,e		;see if past end
 08CD B8        	cmp	b		;verify between 1 and 26/50
 08CE DAD308    	jc	dWtSec		;good sector, compute bc
                
 08D1 1E01      dSec1	mvi	e,1		;restart at sector 1
                				;fall into dWtSec
                
                ;--------------------------------------------------------------
                ; dWtSec - wait for sector specified in e. For the DD
                ;    controller, this routine simply returns the offset
                ;    of the sector within this track in bc.
                ; On Entry:
                ;    Drive is selected, motor is running
                ;    e = desired sector number (must be 1-50 for DD)
                ; On Exit:
                ;    e = sector number
                ;    bc = byte offset of this sector in a track
                ;--------------------------------------------------------------
 08D3 7B        dWtSec	mov	a,e		;save the computed sector
                
                ; compute bc=128*(sector-1)
                
 08D4 D601      	sui	1		;zero index and clear carry
 08D6 1F        	rar
 08D7 47        	mov	b,a		;b=sector >> 1
                
 08D8 1F        	rar			;put lsbit into msbit	
 08D9 E680      	ani	80h
 08DB 4F        	mov	c,a		;bc=128*e
 08DC C9        	ret
                
                
                ;**************************************************************************
                ; 
                ;  Data area
                ;
                ;**************************************************************************
                ; Disk variables
                
 08DD           drvNum	ds	1		;drive number to use
 08DE           trkNum	ds	1		;track number to read
 08DF           numSecs	ds	1		;number of sectors in track
 08E0           fWaitHd	ds	1		;E bit (wait head settle) flag
 08E1           trkPtr	ds	2		;pointer into trkBuf (start of next track)
 08E3           bufEnd	ds	2		;end address + 1 of last track spot in RAM
 08E5           bufEndS	ds	2		;saved buf end for non-track 1 buffer
 08E7           secBuf	ds	SECLEN		;sector buffer to reads
                
                ; Retry logic variables
                
 0967           rdRetry	ds	1		;disk read retry counter
 0968           wrRetry	ds	1		;disk write retry counter
                
                ; Xmodem variables
                
 0969           xfrPort	ds	1		;pseudo port for file transfer
 096A           blkNum	ds	1		;current xmodem block number
 096B           rcvBlk	ds	1		;block number received
 096C           rcvNBlk	ds	1		;"not" block number received
 096D           rcvPtr	ds	2		;pointer for start of XMODEM send
                
                ; Misc variables
                
 096F           cpmFlag	ds	1		;non-zero if running under CP/M
 0970           vfyFlag	ds	1		;verify flag
 0971           baseDrv	ds	1		;ascii 1st drive - baseDrv = 0
 0972           	ds	96		;stack space
 09D2 =         ourStk	equ	$
                
                ;------------------------------------------------------------------------------
                ; PR$NIB - DISPLAY VALUE IN A AS A SINGLE DIGIT ASCII-HEXIDECIMAL VALUE.
                ;------------------------------------------------------------------------------
 09D2 F5        PR$NIB:	PUSH	PSW
 09D3 C5        	PUSH	B
                
 09D4 FE0A      	CPI	10		;GREATER THAN 9?
 09D6 DADB09    	JC	NIBOUT		;0-9
 09D9 C607      	ADI	007H
                
 09DB C630      NIBOUT	ADI	'0'
 09DD 47        	MOV	B,A
 09DE CDF707    	CALL	conOut
                
 09E1 C1        	POP	B
 09E2 F1        	POP	PSW
                
 09E3 C9        	RET
                
                ;------------------------------------------------------------------------------
                ; PR$HEX - DISPLAY VALUE IN A AS A TWO DIGIT ASCII-HEXIDECIMAL VALUE.
                ; CLOBBERS A,B.
                ;------------------------------------------------------------------------------
 09E4 47        PR$BYT	MOV	B,A		;STORE VALUE IN B
 09E5 E6F0      	ANI	0F0H		;HIGH NIBBLE
 09E7 0F        	RRC
 09E8 0F        	RRC
 09E9 0F        	RRC
 09EA 0F        	RRC
 09EB CDD209    	CALL	PR$NIB		;PRINT THE 16'S DIGIT
                
 09EE 78        	MOV	A,B
 09EF E60F      	ANI	0FH
 09F1 C3D209    	JMP	PR$NIB		;PRINT THE 1'S DIGIT
                
                ;------------------------------------------------------------------------------
                ; PR$WRD - DISPLAY VALUE IN HL AS A FOUR DIGIT ASCII-HEXIDECIMAL VALUE.
                ; CLOBBERS NONE
                ;------------------------------------------------------------------------------
 09F4 E5        PR$WRD	PUSH	H		;SAVE HL
 09F5 C5        	PUSH	B		;SAVE BC
 09F6 F5        	PUSH	PSW		;SAVE AF
 09F7 7C        	MOV	A,H		;STORE MSB IN A
 09F8 CDE409    	CALL	PR$BYT		;PRINT MSB
                
 09FB 7D        	MOV	A,L		;STORE LSB IN A
 09FC CDE409    	CALL	PR$BYT		;PRINT LSB
 09FF F1        	POP	PSW
 0A00 C1        	POP	B
 0A01 E1        	POP	H
 0A02 C9        	RET
                
                ;******************************************************
                ;********                                     *********
                ;********  JADE DOUBLE D ROUTINES START HERE  *********
                ;********                                     *********
                ;******************************************************
                
                ;******************************************************
                ; SET DOUBLE D SYSTEM PORT ADDRESS		      *
                ;******************************************************
                
 0043 =         D$PORT	EQU	043H	;DOUBLE D PORT ADDRESS.
                
                ;*******( SET USER DOUBLE D BOARD REVISION )***********
                
 0001 =         TRUE	EQU	1	;SET TRUE TO LOGIC ONE.
 0000 =         FALSE	EQU	0	;SET FALSE TO LOGIC ZERO
 0000 =         REV$B	EQU	FALSE	;SET TRUE FOR REV B BOARDS.
 0001 =         REV$C	EQU	TRUE	;SET TRUE FOR REV C BOARDS.
 0000 =         MA10	EQU	FALSE	;TRUE IF MA10 JUMPED (REV-B).
                
                ;*******( DEFINE HALT MASK AND BASE ADDRESS)***********
                
                	IF	REV$B
                DS$HLT	EQU	002H	;STATUS PORT HALT INDICATOR.
                DS$ASW	EQU	00CH	;STATUS PORT ADDR SW MASK.
                D$BASE	EQU	0E400H	;SYSTEM WINDOW BASE ADDRESS
                	ENDIF
                
                	IF	MA10
                D$BASE	EQU	0E000H	;SYSTEM WINDOW BASE ADDRESS
                	ENDIF
                
                	IF	REV$C
 0001 =         DS$HLT	EQU	001H	;STATUS PORT HALT INDICATOR.
 000E =         DS$ASW	EQU	00EH	;STATUS PORT ADDR SW MASK.
 E000 =         D$BASE	EQU	0E000H	;SYSTEM WINDOW BASE ADDRESS
                	ENDIF
                
                ;*******( BOOTSTRAP LINKAGE ADDRESS )******************
                
 0040 =         D$ADDR	EQU	0040H	;DOUBLE D ADDRESS POINTER.
 0042 =         D$MASK	EQU	0042H	;DOUBLE D HALT BIT ADDR.
                
                ;*******( DCM HARDWARE COMMANDS )**********************
                
 0080 =         DC$BGN	EQU	080H	;RESET Z80A AND EXECUTE.
 0001 =         DC$MRQ	EQU	001H	;REQUEST MEMORY WINDOW.
 0000 =         DC$MRT	EQU	000H	;RELEASE MEMORY WINDOW.
 0001 =         DC$MB0	EQU	001H	;SELECT MEMORY BANK 0.
 0003 =         DC$MB1	EQU	003H	;SELECT MEMORY BANK 1.
 0002 =         DC$EXC	EQU	002H	;ISSUE DOUBLE D INTERRUPT.
                
                ;*******( DCM MEMORY ADDRESSES DEFINED )***************
                
 0370 =         DD$CBT	EQU	0370H	;COMMAND BLOCK  (BANK 0).
 0380 =         DD$BUF	EQU	0380H	;SECTOR BUFFER  (BANK 0).
 0080 =         DD$BFL	EQU	128	;SECTOR BUFFER LENGTH.
 0300 =         DD$FBF	EQU	0300H	;FORMAT BUFFER	(BANK 1).
 0100 =         DD$FBL	EQU	0100H	;FORMAT BUFFER LENGTH.
 03A0 =         DD$DPB	EQU	03A0H	;ID SEC DPB	(BANK 0).
 03B1 =         DD$DDF	EQU	03B1H	;ID SEC FLAGS	(BANK 0).
                
                ;*******( DCM COMMANDS )*******************************
                
 0000 =         DCM$LOG	EQU	000H	;LOG ON DISKETTE.
 0001 =         DCM$RDS	EQU	001H	;READ SECTOR.
 0002 =         DCM$WRS	EQU	002H	;WRITE SECTOR.
 0003 =         DCM$FMT	EQU	003H	;FORMAT TRACK.
 0004 =         DCM$ADR	EQU	004H	;ADDRESS.
 0005 =         DCM$LST	EQU	005H	;LIST CHARACTER.
 0006 =         DCM$LCK	EQU	006H	;LIST STATUS.
 0007 =         DCM$IDL	EQU	007H	;IDLE.
                
                ;*******( STATUS BIT DEFINITIONS )*********************
                
 0080 =         ST$DNR	EQU	080H	;DRIVE NOT READY
 0040 =         ST$WRP	EQU	040H	;WRITE PROTECTED
 0020 =         ST$BT5	EQU	020H	;NOT ASSIGNED
 0010 =         ST$RNF	EQU	010H	;RECORD NOT FOUND
 0008 =         ST$CRC	EQU	008H	;CRC ERROR
 0004 =         ST$LDE	EQU	004H	;LOST DATA ERROR
 0002 =         ST$HME	EQU	002H	;DRIVE HOME ERROR
 0001 =         ST$TSD	EQU	001H	;TWO SIDES FLAG (FORMAT)
 0000 =         ST$NOE	EQU	000H	;NO ERROR
                
                ;******************************************************
                ; INIT DOUBLE D AND EXECUTE LOGON COMMAND	      *
                ;******************************************************
                
 0A03 DB43      INI$DD:	IN	D$PORT		;INPUT STATUS PORT.
 0A05 E60E      	ANI	DS$ASW		;MASK FOR ADDR SWS.
 0A07 07        	RLC			;POSITION BITS.
 0A08 F6E0      	ORI     D$BASE SHR 8	;OR IN BASE ADDR.
 0A0A 67        	MOV	H,A		;HIGH BYTE VALUE.
 0A0B 2E00      	MVI	L,0		;LOW BYTE VALUE.
 0A0D 224000    	SHLD    D$ADDR		;STORE THE ADDRESS
                
 0A10 3E01      	MVI	A,DS$HLT	;LOAD HALT BIT MASK.
 0A12 324200    	STA	D$MASK		;STORE FOR BIOS USE.
                
 0A15 3ADD08    	LDA	drvNum		;SET DRIVE NUMBER
 0A18 32E10A    	STA	DCM$DRV
                
 0A1B AF        	XRA	A		;SET TRACK NUMBER
 0A1C 32E20A    	STA	DCM$TRK
                
 0A1F 3C        	INR	A		;SET SECTOR NUMBER
 0A20 32E30A    	STA	DCM$SEC
                	
 0A23 78        	MOV	A,DCM$LOG	;TRY THE LOGON COMMAND
 0A24 CD970A    	CALL	DSK$EX		;Z CLEAR AND ERROR IN A
                
 0A27 C9        	RET
                
                ;******************************************************
                ; PUT DCM DISK BUFFER FROM SOURCE IN HL		      *
                ;******************************************************
                
 0A28 3E01      PUT$DB:	MVI	A,DC$MB0	;REQUEST BANK 0
 0A2A D343      	OUT	D$PORT
                
 0A2C EB        	XCHG			;HL TO DE
 0A2D 018000    	LXI	B,DD$BFL	;NMBR BYTE TO MOVE.
 0A30 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0A33 117003    	LXI	D,DD$CBT	;COMMAND BYTE OFFSET.
 0A36 19        	DAD	D		;HL NOW PTS CMND BLK.
 0A37 EB        	XCHG			;HL=SRC DE=SEC BUF
 0A38 CDCA0A    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
 0A3B C9        	RET
                
                ;******************************************************
                ; GET DCM DISK BUFFER AND STORE IN HL		      *
                ;******************************************************
                
 0A3C 3E01      GET$DB:	MVI	A,DC$MB0	;REQUEST BANK 0
 0A3E D343      	OUT	D$PORT
                
 0A40 EB        	XCHG			;HL TO DE
 0A41 018000    	LXI	B,DD$BFL	;NMBR BYTE TO MOVE.
 0A44 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0A47 117003    	LXI	D,DD$CBT	;COMMAND BYTE OFFSET.
 0A4A 19        	DAD	D		;HL NOW PTS CMND BLK.
 0A4B CDCA0A    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
 0A4E C9        	RET
                
                ;******************************************************
                ; GET DCM CONTROL BLOCK  			      *
                ;******************************************************
                
 0A4F 3E01      GET$CB:	MVI	A,DC$MB0	;REQUEST BANK 0
 0A51 D343      	OUT	D$PORT
                
 0A53 010800    	LXI	B,8		;NMBR BYTE TO MOVE.
 0A56 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0A59 117003    	LXI	D,DD$CBT	;COMMAND BYTE OFFSET.
 0A5C 19        	DAD	D		;HL NOW PTS CMND BLK.
 0A5D 11E00A    	LXI	D,DCM$CMD	;JDDUTIL CMND BLOCK.
 0A60 CDCA0A    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
 0A63 C9        	RET
                
                ;******************************************************
                ; PUT DCM CONTROL BLOCK  			      *
                ;******************************************************
                
 0A64 3E01      PUT$CB:	MVI	A,DC$MB0	;REQUEST BANK 0
 0A66 D343      	OUT	D$PORT
                
 0A68 010700    	LXI	B,7		;NMBR BYTE TO MOVE.
 0A6B 2A4000    	LHLD	D$ADDR		;DD SYS ADDRESS.
 0A6E 117003    	LXI	D,DD$CBT	;COMMAND BYTE OFFSET.
 0A71 19        	DAD	D
 0A72 EB        	XCHG			;DE NOW PTS CMND BLK.
 0A73 21E00A    	LXI	H,DCM$CMD	;PC2FLOP CMND BLOCK.
 0A76 CDCA0A    	CALL	BLK$MV		;PERFORM BLOCK MOVE.
 0A79 C9        	RET
                
                ;******************************************************
                ; SET COMMAND     				      *
                ;******************************************************
                
 0A7A 32E00A    SETCMD	STA	DCM$CMD		;SAVE DCM COMMAND.
 0A7D C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; SET DRIVE NUMBER				      *
                ;******************************************************
                
 0A7E 32E10A    SETDRV	STA	DCM$DRV		;SAVE DRIVE NUMBER.
 0A81 C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; SET TRACK NUMBER				      *
                ;******************************************************
                
 0A82 32E20A    SETTRK	STA	DCM$TRK		;SAVE TRACK NUMBER.
                
 0A85 0E1A      	MVI	C,NUMSEC	;26 SECTORS PER TRACK
 0A87 FE01      	CPI	1		;TRACK 1?
 0A89 C28E0A    	JNZ	NTRK1		;NOT TRACK 1
 0A8C 0E32      	MVI	C,NUMSEC1	;50 SECTORS PER TRACK
                
 0A8E 79        NTRK1	MOV	A,C
 0A8F 32DF08    	STA	numSecs
 0A92 C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; SET SECTOR NUMBER				      *
                ;******************************************************
                
 0A93 32E30A    SETSEC:	STA	DCM$SEC		;SAVE SECTOR NUMBER.
 0A96 C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; DOUBLE D EXECUTION SUBROUTINE			      *
                ;******************************************************
                
                ;*******( COMMAND BLOCK TO DOUBLE D AND EXEC )*********
                
 0A97 E5        DSK$EX	PUSH	H		;SAVE H
 0A98 32E00A    	STA	DCM$CMD		;STORE DCM COMMAND.
 0A9B CD640A    	CALL	PUT$CB
                
 0A9E 3E02      	MVI	A,DC$EXC	;LOAD DD INTERRUPT.
 0AA0 D343      	OUT	D$PORT		;ISSUE DD INTERRUPT.
                
                ;*******( WAIT FOR DOUBLE D HALT )*********************
                
 0AA2 3A4200    	LDA	D$MASK		;LOAD HALT BIT MASK.
 0AA5 47        	MOV	B,A		;MASK IN B REGISTER.
 0AA6 11FFFF    	LXI	D,0FFFFH	;LOOP COUNTER
 0AA9 DB43      WAIT	IN	D$PORT		;READ DD STATUS.
 0AAB A0        	ANA	B		;TEST HALT* FLAG.
 0AAC CAC10A    	JZ	HALTED		;TEST UNTIL HALTED.
 0AAF 1B        	DCX	D
 0AB0 7B        	MOV	A,E
 0AB1 B2        	ORA	D
 0AB2 C2A90A    	JNZ	WAIT
                
 0AB5 219A07    	LXI	H,mDDTO		;DISPLAY NO DD FOUND
 0AB8 CD3D03    	CALL	dispMsg
 0ABB 3E80      	MVI	A,ST$DNR	;SET DRIVE NOT READY
 0ABD B7        	ORA	A		;CLEAR ZERO FLAG
 0ABE C3C80A    	JMP	EX$DONE
                
                ;*******( GET DOUBLE D STATUS )************************
                
 0AC1 CD4F0A    HALTED	CALL	GET$CB
 0AC4 3AE70A    	LDA	DCM$STS
 0AC7 A7        	ANA	A		;TEST FOR ERRORS.
 0AC8 E1        EX$DONE	POP	H		;RESTORE H
 0AC9 C9        	RET			;RETURN TO CALLER.
                
                ;******************************************************
                ; BLOCK MOVE SUBROUTINE (Z80 BLOCK MOVE REGISTERS)    *
                ;******************************************************
                
 0ACA 7E        BLK$MV:	MOV	A,M		;GET BYTE.
 0ACB 23        	INX	H		;INC POINTER
 0ACC EB        	XCHG			;GET DESTINATION.
 0ACD 77        	MOV	M,A		;PUT BYTE.
 0ACE 23        	INX	H		;INC POINTER
 0ACF EB        	XCHG			;GET SOURCE.
 0AD0 0B        	DCX	B		;ONE LESS TO DO.
 0AD1 78        	MOV	A,B		;GET HI COUNT.
 0AD2 B1        	ORA	C		;GET LO COUNT.
 0AD3 C2CA0A    	JNZ	BLK$MV		;FINISH LOADING.
 0AD6 C9        	RET
                
                ;******************************************************
                ; DISPLAY DCM ERROR IN A 			      *
                ;******************************************************
                
 0AD7 21C407    DCM$ER	LXI	H,mDNR		;DRIVE NOT READY
 0ADA E680      	ANI	ST$DNR
 0ADC C23D03    	JNZ	dispMsg
                
 0ADF C9        	RET
                
                ;******************************************************
                ; DOUBLE D - DCM COMMAND BLOCK BUFFER		      *
                ;******************************************************
                
 0AE0 00        DCM$CMD DB	0		;DCM COMMAND.
 0AE1 00        DCM$DRV DB	0		;DRIVE NUMBER.
 0AE2 00        DCM$TRK DB	0		;TRACK NUMBER.
 0AE3 00        DCM$SEC DB	0		;SECTOR NUMBER.
 0AE4 00        DCM$SP0 DB	0		;SPARE BYTE 0.
 0AE5 00        DCM$CHR DB	0		;LIST CHARACTER.
 0AE6 00        DCM$MOD DB	00000000B	;MODE CONTROLS.
 0AE7 00        DCM$STS DB	0		;COMMAND STATUS.
                
                ;******************************************************
                ; TRACK BUFFER RUNS FROM HERE TO THE END OF MEMORY    *
                ;******************************************************
                
 0AE8 =         trkBuf	equ	$
                
 0AE8           	end
